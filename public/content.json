{"pages":[{"title":"About","text":"YC (Lin Yu-Chien)應該不會有人來看吧? Mail: npr286rx@gmail.com document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"FreeRTOS API Interface, Synchronization & Coding Style","text":"API Interface這張圖是FreeRTOS與硬體的關係，提供Semaphore, Queue, Timer, Task 等kernel services，來讓我們架構上層的應用，該應用可以包含n個task，透過kernel與device driver (Board support package Layer)溝通，執行各種操作，例如UART driver, SPI driver等，在由driver控制硬體週邊（SPI, I2C, Timer, GPIOs, etc），FreeRTOS完全不包含任何跟硬體周邊有關的程式。 用FreeRTOS API產生Task, Semaphore, Queue…等, 會消耗system heap的記憶體 FreeRTOS提供五種heap management schemes，第一種只能malloc，不能free heap memory，也可以寫自己定義的scheme RTOS同步(Synchronization)RTOS需要能處理同步問題，用Producer & Consumer描述task的行為 可以做到signaling的方法有下列幾種 Events (Flags) Semaphores (Counting & Binary) Mutex Queue and Message Queue Pips Mailboxes Signals (UNIX like signals) FreeRTOS Coding StyleMacros巨集的前綴可以知道有在哪個檔案中被定義，通常前綴是小寫例如：FreeRTOSConfig.h中定義configUSE_PREEMPTION Variables變數的命名慣例： type prefix unsigned long ul unsigned short us unsigned char uc non stdint x unsigned non stdint u enumerate e 指標則會再加個p，例如uint16_t的指標是pus Function函式的命名慣例是前綴代表回傳值的類型，而v代表void例如：task.c內定義的vTaskDelete()，回傳void 此外file scope static function (private function)的前綴是prv document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/01/08/FreeRTOS-API-Interface-Synchronization-Coding-Style/"},{"title":"FreeRTOS - Task Creation觀念彙整","text":"建立一個stack為512 bytes的task需要佔用多少記憶體空間？ 512 + sizeof(TCB) bytes 同時Task Control Block也在stack中動態配置。TCB結構可在FreeRTOS kernel原始碼的task.c中找到。 TCB結構的第一個成員是？ task state task size task priority 指向task stack頂端的指標 直到啟動scheduler以前task都不會執行？ true 透過vTaskStartScheduler()啟動 FreeRTOS的預設scheduler是基於哪種scheduling algorithm？ priority based preemptive scheduling 在priority based preemptive scheduling下，有高優先權與低優先權的2個task，目前CPU由高優先權task佔用，如何使低優先權task能夠執行？ 對高優先權task的blocking, suspending 或 task yielding 可使低優先權task得到CPU使用權 是否可以靜態配置task與靜態配置的優點？ 可 優點：RTOS物件可以置於特定位址(RAM的全域空間)、最大ram使用量可在link time被決定而不是run time、開發者不需考慮動態配置失敗的問題、讓FreeRTOS可使用在禁止動態配置記憶體的應用 https://www.freertos.org/xTaskCreateStatic.html https://www.freertos.org/Static_Vs_Dynamic_Memory_Allocation.html 宣告並初始化在task函式中的靜態變數實際上佔用哪個記憶體空間？ stack of task stack of RAM heap of RAM global space of RAM 宣告並初始化在task函式中的非靜態變數實際上佔用哪個記憶體空間？ stack of task stack of RAM heap of RAM global space of RAM document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/12/13/FreeRTOS-task-creation-concepts/"},{"title":"FreeRTOS - Hook Function","text":"參考：https://www.freertos.org/a00016.html Idle task hook function RTOS Tick hook function Dynamic memory allocation (Malloc) faild hook function Stack overflow hook function 必要時實做這些hook function，當有該事件發生rtos就會自動執行他們 Idle Task Hook Functionidle task作為閒置時rtos的要做的工作，要在FreeRTOSConfig.h中設定configUSE_IDLE_HOOK為1，並實做void vApplicationIdleHook(void);，一般可以在閒置中降低mcu運算量節能功耗 1234void vApplicationIdleHook(void) { // configUSE_IDLE_HOOK should be 1 in FreeRTOSConfig.h // idle task implementation } RTOS Tick Hook Function1234void vApplicationTickHook(void) { // configUSE_TICK_HOOK should be 1 in FreeRTOSConfig.h // tick task implementation } Malloc Failed Hook Function1234void vApplicationMallocFailedHook(void) { // configUSE_MALLOC_FAILED_HOOK should be 1 in FreeRTOSConfig.h // malloc failed task implementation } Stack Overflow Hook Function1234void vApplicationStackOverflowHook(TaskHandle_t xTask, signed char *pcTaskName) { // configUSE_FOR_STACK_OVERFLOW should be 1 in FreeRTOSConfig.h // stack overflow task implementation } Example要讓mcu進入sleep mode，可用WFI(Wait for interrupt)這個16-bit Thumb instruction，適用於Cortex-M0, M3, M4與M7系列，當執行__WFI()，processor會暫停clock，停止指令執行，直到下個中斷發生或者進入debug模式，用於有條件的進入sleep狀態，有分normal與deep sleep mode。 使用硬體: NUCLEO-F411REdata brief: https://www.st.com/resource/en/data_brief/nucleo-f411re.pdf document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/12/09/FreeRTOS-hook-functions/"},{"title":"Decision Tree and Random Forest - Lending Club 信貸資料分析","text":"Dataset Download各column所代表的意義如下 credit.policy: 1 if the customer meets the credit underwriting criteria of LendingClub.com, and 0 otherwise. purpose: The purpose of the loan (takes values “credit_card”, “debt_consolidation”, “educational”, “major_purchase”, “small_business”, and “all_other”). int.rate: The interest rate of the loan, as a proportion (a rate of 11% would be stored as 0.11). Borrowers judged by LendingClub.com to be more risky are assigned higher interest rates. installment: The monthly installments owed by the borrower if the loan is funded. log.annual.inc: The natural log of the self-reported annual income of the borrower. dti: The debt-to-income ratio of the borrower (amount of debt divided by annual income). fico: The FICO credit score of the borrower. days.with.cr.line: The number of days the borrower has had a credit line. revol.bal: The borrower’s revolving balance (amount unpaid at the end of the credit card billing cycle). revol.util: The borrower’s revolving line utilization rate (the amount of the credit line used relative to total credit available). inq.last.6mths: The borrower’s number of inquiries by creditors in the last 6 months. delinq.2yrs: The number of times the borrower had been 30+ days past due on a payment in the past 2 years. pub.rec: The borrower’s number of derogatory public records (bankruptcy filings, tax liens, or judgments). 函式庫1234import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sns 引入資料集12df = pd.read_csv('loan_data.csv')df.head() 1df.info() RangeIndex: 9578 entries, 0 to 9577Data columns (total 14 columns):credit.policy 9578 non-null int64purpose 9578 non-null objectint.rate 9578 non-null float64installment 9578 non-null float64log.annual.inc 9578 non-null float64dti 9578 non-null float64fico 9578 non-null int64days.with.cr.line 9578 non-null float64revol.bal 9578 non-null int64revol.util 9578 non-null float64inq.last.6mths 9578 non-null int64delinq.2yrs 9578 non-null int64pub.rec 9578 non-null int64not.fully.paid 9578 non-null int64dtypes: float64(6), int64(7), object(1)memory usage: 1.0+ MB 1df.describe() 資料分析個別顯示credit.policy為1跟0的fico值分布之histogram 12345plt.figure(figsize=(10, 6))df[ df['credit.policy'] == 1 ]['fico'].hist(bins= 35, color = 'blue', label = 'Credit Policy = 1', alpha = 0.6)df[ df['credit.policy'] == 0 ]['fico'].hist(bins= 35, color = 'red', label = 'Credit Policy = 0', alpha = 0.6)plt.legend()plt.title('FICO') 同上，改成分為not.fully.paid為1、0的histogram 12345plt.figure(figsize=(10, 6))df[ df['not.fully.paid'] == 1 ]['fico'].hist(bins= 35, color = 'blue', label = 'not.fully.paid = 1', alpha = 0.6)df[ df['not.fully.paid'] == 0 ]['fico'].hist(bins= 35, color = 'red', label = 'not.fully.paid = 0', alpha = 0.6)plt.legend()plt.title('FICO') 使用seaborn，產生countplot來顯示每種purpose對應的not.fully.paid為0、1的資訊 12plt.figure(figsize=(11, 7))sns.countplot(x = 'purpose', hue = 'not.fully.paid', data = df) 顯示fico值與int.rate之間的關係 1sns.jointplot(x = 'fico', y= 'int.rate', data = df) 12plt.figure(figsize=(11,7))sns.lmplot(y= 'int.rate', x= 'fico', data = loans, hue = 'credit.policy', col = 'not.fully.paid', fit_reg=False) 資料處理 將類別變數改成dummy variable 123cat_feats = ['purpose'] #紀錄類別column名稱final_data = pd.get_dummies(df, columns=cat_feats, drop_first=True) #drop_first = True會丟棄第一行(但仍然能夠藉由其他行推斷類別)，減少不必要的資料 切分訓練、測試資料123456from sklearn.model_selection import train_test_splitX = final_data.drop('not.fully.paid', axis = 1)y = final_data['not.fully.paid']X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3) 訓練Decision Tree model1234from sklearn.tree import DecisionTreeClassifierdTree = DecisionTreeClassifier()dTree.fit(X_train, y_train) 預測與評估1234567891011121314151617181920from sklearn.metrics import classification_report, confusion_matrixpredictions = dTree.predict(X_test)print(confusion_matrix(y_test, predictions))'''[[2006 395] [ 357 116]]'''print(classification_report(y_test, predictions))''' precision recall f1-score support 0 0.85 0.84 0.84 2401 1 0.23 0.25 0.24 473avg / total 0.75 0.74 0.74 2874''' 訓練Random Forest model1234from sklearn.ensemble import RandomForestClassifierrfc = RandomForestClassifier(n_estimators= 300)rfc.fit(X_train, y_train) 預測與評估1234567891011121314151617181920from sklearn.metrics import classification_report, confusion_matrixpredictions = dTree.predict(X_test)print(confusion_matrix(y_test, predictions))'''[[2363 38] [ 447 26]]'''print(classification_report(y_test, predictions))''' precision recall f1-score support 0 0.84 0.98 0.91 2401 1 0.41 0.05 0.10 473avg / total 0.77 0.83 0.77 2874''' document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/10/11/ML-course-note-DecisionTree-RandomForest/"},{"title":"Emergency - 911 Calls 資料分析","text":"Dataset : Kaggle - Emergency - 911 Calls / Montgomery County, PA 使用Python套件 數據分析 NumPy Pandas 資料視覺化 matplotlib Seaborn 1234import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sns 讀取dataset12df = pd.read_csv('911.csv')df.info() 1df.head() 撥打911最多的5個郵遞區號12345678df['zip'].value_counts().head() # 19401.0 6979# 19464.0 6643# 19403.0 4854# 19446.0 4748# 19406.0 3174# Name: zip, dtype: int64 撥打911最多的5個鄉鎮12345678df['twp'].value_counts().head()# LOWER MERION 8443# ABINGTON 5977# NORRISTOWN 5890# UPPER MERION 5227# CHELTENHAM 4575# Name: twp, dtype: int64 title欄有幾筆唯一的資料1234# len(df['title'].unique()) df['title'].nunique()# 110 分析title欄的類別，新增Reason欄位1234567#先取出類別x = df['title'].iloc[0]x.split(':')[0] # 'EMS'# 新增Reasons欄位df['Reason'] = df['title'].apply(lambda title: title.split(':')[0])df 各種Reason案件數量123456df['Reason'].value_counts()# EMS 48877# Traffic 35695# Fire 14920# Name: Reason, dtype: int64 使用Seaborn產生圖表 1sns.countplot(x = 'Reason', data = df, palette = 'viridis') 分析timeStamp，新增Hour、Month、Day of Week欄位 使用pandas的to_datetime轉成Date Time物件 123456789101112type(df['timeStamp'].iloc[0]) # strdf['timeStamp'] = pd.to_datetime(df['timeStamp'])type(df['timeStamp'].iloc[0]) # pandas._libs.tslibs.timestamps.Timestamptime = df['timeStamp'].iloc[0]time.hour # 取出hour值# 新增欄位df['Hour'] = df['timeStamp'].apply(lambda time: time.hour)df['Month'] = df['timeStamp'].apply(lambda time: time.month)df['Day of Week'] = df['timeStamp'].apply(lambda time: time.dayofweek) 重新mapping星期幾的欄位 123dmap = {0:'Mon',1:'Tue',2:'Wed',3:'Thu',4:'Fri',5:'Sat',6:'Sun'}df['Day of Week'] = df['Day of Week'].map(dmap)df 用Seaborn產生橫軸為Day of Week計量圖表 12sns.countplot(x = 'Day of Week', data = df, hue = 'Reason', palette = 'viridis') plt.legend(bbox_to_anchor= (1.05, 1), loc = 2, borderaxespad = 0.)# 把legend放外面避免重疊 Month為橫軸 12sns.countplot(x = 'Month', data = df, hue = 'Reason', palette = 'viridis') plt.legend(bbox_to_anchor= (1.05, 1), loc = 2, borderaxespad = 0.) Day of Week對Hour的Heat map 需使用groupby與unstack重構dataFrame 1dayHour = df.groupby(by = ['Day of Week', 'Hour']).count()['Reason'].unstack() 用新的dataFrame產生Heat map 12plt.figure(figsize=(12,6))sns.heatmap(dayHour, cmap = 'viridis') document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/10/11/ML-course-note-DataAnalysis-Emergency911/"},{"title":"FreeRTOS - Scheduler與設定檔 觀念彙整","text":"如何使用co-operative排程而不是預設的preemptive？ FreeRTOSConfig.h 中將configUSE_PREEMPTION定義為0 定義time slice 兩個kernal tick (SysTick)中斷的時間差 如何調整time slice？ 修改configTICK_RATE_HZ的值 FreeRTOSConfigh.h 與MCU硬體無關？ False 其中定義的中斷優先權會根據硬體而有所差異 若configTICK_RATE_HZ設為125 Hz，則time slice為？ $\\frac{1}{125} = 8$ ms configTICK_RATE_HZ設為125 Hz，則32 ms的時間間隔將產生多少tick interrupt？ 4 SysTick Timer是否可被用在其他用途？ False SysTick Timer只能用於kernel ticking Kernel ticking是否能用其他MCU的Timer週邊取代SysTick Timer？ Yes FreeRTOS中是誰觸發context switching？ SysTick inturrput handler ARM Cortex-M處理器中誰負責執行context switching？ PendSV inturrput handler SVC exception會在FreeRTOS應用中觸發幾次？ SVC被用於啟動scheduler所以只有1次 ARM Cortex-M處理器的Task yielding與哪個exception有關？ PendSV PendSV exception的預設優先權為多少？(假設NVIC_PRIO_BITS = 4) 代表有16個優先權 PendSV exception的優先權最大(值最小)，NVIC_PRIO_BITS = 4的情況下優先權最大為0xF0 在cotext switching時有哪些register會被存到stack中？ R0, R1, R2, R3, R12, LR, PC, xPSR [註] PSP (Private Stack Pointer), MSP (Main Stack Pointer) 哪個FreeRTOS函數會設置SVC,PendSV, SysTick exceptions？ vPortStartScheduler() SysTick timer是ARM Cortex-M處理器外的週邊 False SysTick是ARM Cortex-M處理器內部的timer engine MCU System Clock為16 MHz且configTICK_RATE_HZ為1000 Hz的情況下，SysTick counter的值為？ SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1 = 16000 - 1 = 15999 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/12/13/FreeRTOS-scheduler-concepts/"},{"title":"FreeRTOS - Task States","text":"FreeRTOS同樣也有task state，創造task後配置記憶體空間，進入waiting list等待scheduler選取才進去CPU執行(Running state) Blocked state使用時機 需要暫停的task透過vTaskDelay()來達到blocking delay 行程同步，例如先讓一個負責資料處理task進入blocked state，等待data buffer被其他task或interrupt填滿，再unblock FreeRTOS的queue、binary semaphore、counting semaphore、recursive semaphore與mutex等可以達到行程同步的功能需要做tack blocking Suspended state Suspended state是non—running state的一種，很少使用，task一旦進入suspended則會禁止scheduler對它進行排程，只能透過vTaskSuspend()來進入該狀態vTaskResume()來脫離並進入waiting list Example - Blocking Delay document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/12/13/FreeRTOS-task-state/"},{"title":"K-Means-Clustering演算法 - 腫瘤分類","text":"非監督式機器學習演算法，本文將依照資料集的features來分類良性或惡性腫瘤(乳癌)並用cufflinks作圖幫助我們做初步的資料分析dataset來自scikit-learn 函式庫12345678910111213import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sns%matplotlib inlinefrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplotimport cufflinks as cf# For Notebooksinit_notebook_mode(connected=True)# For offline usecf.go_offline() scikit-learn資料集12345678910from sklearn.datasets import load_breast_cancerdata = load_breast_cancer()data.keys()# print(data.DESCR)df = pd.DataFrame(data.data, columns= data.feature_names)df['target'] = data.targetdf.head() cufflinks 互動式資料分析1df.iplot(kind='scatter',x='mean radius',y='mean texture',mode='markers',size=10, categories= 'target', xTitle='mean radius', yTitle='mean texture') 具有部分縮放功能可查看資料細節 KMeans演算法由scikit-learn的cluster引入12345from sklearn.cluster import KMeanskmeans = KMeans(n_clusters=2) #分成2類kmeans.fit(df.drop('target', axis=1)) #注意! 非監督式不需要Label 查看重心1kmeans.cluster_centers_ array([[1.25562991e+01, 1.85703653e+01, 8.11234703e+01, 4.96061872e+02, 9.48844977e-02, 9.10998174e-02, 6.24377642e-02, 3.34325434e-02, 1.78057991e-01, 6.34540183e-02, 3.04190868e-01, 1.21515320e+00, 2.15288059e+00, 2.37852922e+01, 7.17326256e-03, 2.34746895e-02, 2.87455128e-02, 1.06363242e-02, 2.06135799e-02, 3.74750297e-03, 1.40439018e+01, 2.47095434e+01, 9.19375114e+01, 6.19647945e+02, 1.29959110e-01, 2.23311758e-01, 2.19214947e-01, 9.13298425e-02, 2.83553653e-01, 8.32819406e-02], [1.93799237e+01, 2.16945802e+01, 1.28231298e+02, 1.18592977e+03, 1.01294580e-01, 1.48612977e-01, 1.76939466e-01, 1.00698779e-01, 1.91539695e-01, 6.06029008e-02, 7.42803817e-01, 1.22253817e+00, 5.25058015e+00, 9.56781679e+01, 6.59868702e-03, 3.21766947e-02, 4.24197710e-02, 1.56739847e-02, 2.03039695e-02, 3.95338931e-03, 2.37094656e+01, 2.89126718e+01, 1.58496183e+02, 1.75302290e+03, 1.40424733e-01, 3.57757710e-01, 4.49306107e-01, 1.92431069e-01, 3.11881679e-01, 8.61654962e-02]]) 分群結果1kmeans.labels_ array([0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1]) 視覺化比較分類結果12345f, (ax1, ax2) = plt.subplots(1, 2, sharey=True,figsize=(10,5))ax1.set_title('K Means')ax1.scatter(df['mean radius'], df['mean texture'], c = kmeans.labels_)ax2.set_title('Original')ax2.scatter(df['mean radius'], df['mean texture'], c = df['target']) 很明顯良性惡性的結果label反了(因為n_clusters=2，所以類型非0即1)，所以修改預測數值 (此步驟不一定要做) 12func = lambda x : 1 if x ==0 else 0predictions = np.array([func(x) for x in kmeans.labels_]) 再次作圖 12345f, (ax1, ax2) = plt.subplots(1, 2, sharey=True,figsize=(10,5))ax1.set_title('K Means')ax1.scatter(df['mean radius'], df['mean texture'], c = predictions)ax2.set_title('Original')ax2.scatter(df['mean radius'], df['mean texture'], c = df['target']) 評估預測準確度 123456789101112131415161718from sklearn.metrics import classification_report, confusion_matrixprint(confusion_matrix(df['target'], predictions))\"\"\" [[130 82] [ 1 356]]\"\"\" print(classification_report(df['target'], predictions))\"\"\" precision recall f1-score support 0 0.99 0.61 0.76 212 1 0.81 1.00 0.90 357avg / total 0.88 0.85 0.84 569\"\"\" document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/10/12/ML-course-note-K-means/"},{"title":"Linear Regression - Boston house-prices dataset  房價預測模型","text":"http://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_boston.html 引入Libraries1234import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport seaborn as sns 讀取Dataset123from sklearn.datasets import load_bostonboston = load_boston()print(boston.DESCR) #查看說明文件 CRIM：城鎮人均犯罪率 ZN：佔地面積超過25,000平方英尺的住宅用地比例。 INDUS：每個城鎮的非零售業務面積比例 CHAS：Charles River虛擬變量（如果管道限制河流則= 1;否則為0） NOX：一氧化氮濃度（每千萬份） RM：每棟住宅的平均房間數 AGE：1940年以前建造的自住單位比例 DIS：到波士頓五個就業中心的加權距離 RAD：徑向高速公路的可達性指數 TAX：每10,000美元的全額房產稅率 PTRATIO：城鎮的學生與教師比例 B：1000（Bk - 0.63）^ 2其中Bk是城鎮黑人的比例 LSTAT：人口狀況下降％ MEDV：自住房屋的中位數價值(單位: USD1000) 整理dataFrame 1234df = pd.DataFrame(boston.data.T, ['CRIM','ZN','INDUS','CHAS','NOX','RM' ,'AGE','DIS','RAD','TAX', 'PTRATIO','B','LSTAT']) #有13個featuredf = df.Tdf['MEDV'] = boston.target.T #MEDV即預測目標向量df.head() 查看各項統計數據1df.describe() Exploratory data analysis1sns.pairplot(df) 對單一變量的數值分布 1sns.distplot(df['MEDV']) 查看各種feature間的相關性記得用corr()產生新的dataFrame 12plt.figure(figsize=(18, 12))sns.heatmap(df.corr(), annot= True, cmap = 'coolwarm') 訓練線性回歸模型載入sklearn123456from sklearn.model_selection import train_test_splitX = df[['CRIM','ZN','INDUS','CHAS','NOX','RM' ,'AGE','DIS','RAD','TAX', 'PTRATIO','B','LSTAT']]y = df['MEDV']#分出30%的資料作為test setX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3) 使用LinearRegression建立並訓練模型123from sklearn.linear_model import LinearRegressionlm = LinearRegression()lm.fit(X_train,y_train) #Fit linear model 到這裡就完成模型的訓練，接著看看訓練成果 模型評估1lm.coef_ # 查看各項係數 表列係數 123coeff_df = pd.DataFrame(lm.coef_, ['CRIM','ZN','INDUS','CHAS','NOX','RM' ,'AGE','DIS','RAD','TAX', 'PTRATIO','B','LSTAT'], columns = ['Coefficient'])coeff_df['註記'] = ['城鎮人均犯罪率','佔地面積超過25,000平方英尺的住宅用地比例','每個城鎮的非零售業務面積比例','Charles River虛擬變量（如果管道限制河流則= 1;否則為0）','一氧化氮濃度（每千萬份）','每棟住宅的平均房間數','1940年以前建造的自住單位比例','到波士頓五個就業中心的加權距離','徑向高速公路的可達性指數','每10,000美元的全額房產稅率','城鎮的學生與教師比例','1000*(Bk - 0.63)^2，其中Bk是城鎮黑人的比例','人口狀況下降百分比']coeff_df coefficients代表feature每單位增加對房價(MEDV)的增量ex.平均房間數增加1，則房價(MEDV)會增加3.890080(單位:USD1000) 用建立的模型做預測1predictions = lm.predict(X_test) predictions即為預測房價，真實房價為y_test用scatter plot看預測正確性，高度正相關代表預測誤差越小 123plt.scatter(y_test,predictions) plt.xlabel('Measured')plt.ylabel('Predicted') 用distribution plot檢查預測與實際的差值，residual = y_test-predictions若residual位置集中在0的常態分布，則模型建立完成 1sns.distplot((y_test-predictions), bins=50); Regression Evaluation Metrics評估回歸模型Mean Absolute Error (MAE) is the mean of the absolute value of the errors: $$\\frac 1n\\sum_{i=1}^n|y_i-\\hat{y}_i|$$ Mean Squared Error (MSE) is the mean of the squared errors: $$\\frac 1n\\sum_{i=1}^n(y_i-\\hat{y}_i)^2$$ Root Mean Squared Error (RMSE) is the square root of the mean of the squared errors: $$\\sqrt{\\frac 1n\\sum_{i=1}^n(y_i-\\hat{y}_i)^2}$$ 以上都是損失函數，越大代表與真實數據的不一致性越大，所以我們需要最小化他們才能做出正確預測 12345678from sklearn import metricsprint('MAE:', metrics.mean_absolute_error(y_test, predictions))print('MSE:', metrics.mean_squared_error(y_test, predictions))print('RMSE:', np.sqrt(metrics.mean_squared_error(y_test, predictions)))# MAE: 82288.22251914957# MSE: 10460958907.209501# RMSE: 102278.82922291153 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/10/11/ML-course-note-LinearRegression/"},{"title":"K Nearest Neighbors 演算法","text":"基本概念如圖將Node分成A、B類，根據X1、X2兩種特徵標出待測物(星號標示)，重點在於k值選擇，若k = 3則相鄰B類Node數量較多，故預測其為B類，k = 6則相鄰A類Node較多，所以預測為A類 dataset來源: 隨機產生，KNN演算法的實行上不必知道各種feature是什麼Download 引入函式庫&載入資料12345678import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as snsdf = pd.read_csv('KNN_Dataset')df.head() 初步資料分析1sns.pairplot(data = df, hue = 'TARGET CLASS') 標準化變數數值型變數標準化，避免ＫＮＮ距離計算時因為單位不同造成失真 可以使用Scikit learn內建標準化功能 123456789from sklearn.preprocessing import StandardScalerscaler = StandardScaler()scaler.fit(df.drop('TARGET CLASS', axis=1)) # 用.transform()方法回傳標準化後的featuresscaler_features = scaler.transform(df.drop('TARGET CLASS', axis=1))# 重新整理dataFramedf_feat = pd.DataFrame(scaler_features, columns=df.columns[:-1]) #columns和原本一樣df_feat.head() 拆分train data與test data123456from sklearn.model_selection import train_test_splitX = df_featy = df['TARGET CLASS']X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3) # 隨機取30%的資料為test data 訓練KNN模型12345from sklearn.neighbors import KNeighborsClassifier#一開始先定k值為1，之後會再測試準確率最高的k值knn = KNeighborsClassifier(n_neighbors = 1)knn.fit(X_train, y_train) 預測與評估1234pred = knn.predict(X_test)from sklearn.metrics import classification_report, confusion_matrixprint(confusion_matrix(y_test, pred)) confusion matrix: [[109 43] [ 41 107]] 1print(classification_report(y_test, pred)) precision recall f1-score support 0 0.73 0.72 0.72 152 1 0.71 0.72 0.72 148avg / total 0.72 0.72 0.72 300 選用適合的k值12345678910error_rate = []for i in range(1, 40): # range夠大即可，一般選1~40 knn = KNeighborsClassifier(n_neighbors=i) knn.fit(X_train, y_train) pred_i = knn.predict(X_test) #np.mean(pred_i != y_test)為預測失敗率 error_rate.append(np.mean(pred_i != y_test)) 圖表化k值對其預測失敗機率 12345plt.figure(figsize=(10, 6))plt.plot(range(1, 40), error_rate, color = 'blue', linestyle= '--', marker = 'o', markerfacecolor = 'red', markersize = 10)plt.title('Error Rate vs. K Value')plt.xlabel('K')plt.ylabel('Error Rate') 可看出k=30時失敗率最低(預測精確度最高) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/10/11/ML-course-note-KNN/"},{"title":"Support-Vector-Machine演算法 - 紅酒種類預測","text":"scikit-learn 內建dataset : wine dataset 函式庫1234import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sns 載入dataset1234from sklearn.datasets import load_winedata = load_wine()data.keys()# print(data.DESCR) 123df = pd.DataFrame(data.data, columns=data.feature_names)df['target'] = data.targetdf.head() 1sns.pairplot(df, hue='target') 切分訓練、測試資料123456from sklearn.model_selection import train_test_splitX = df.drop('target', axis=1)y = df['target']X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) SVM model123from sklearn.svm import SVCmodel = SVC()model.fit(X_train, y_train) 預測與評估1predictions = model.predict(X_test) 12from sklearn.metrics import classification_report, confusion_matrixprint(confusion_matrix(y_test, predictions)) 123[[ 1 18 0] [ 0 21 0] [ 0 13 1]] 1print(classification_report(y_test, predictions)) 1234567 precision recall f1-score support 0 1.00 0.05 0.10 19 1 0.40 1.00 0.58 21 2 1.00 0.07 0.13 14avg / total 0.77 0.43 0.29 54 GridsearchSVM預設參數可能如上面結果效果不佳，scikit-learn提供方法幫助我們找出適合的C、gamma參數的組合，這種方法稱Gridsearch，可以在==GridSearchCV==調用功能，程式如下 123456from sklearn.grid_search import GridSearchCVparam_grid = {'C': [0.1, 1, 10, 100, 1000, 10000], 'gamma':[1, 0.1, 0.01, 0.001, 0.0001, 0.00001], 'kernel': ['rbf']}grid = GridSearchCV(SVC(), param_grid, verbose=3)grid.fit(X_train, y_train) 到此步驟grid已經套用最好的C、gamma組合 12grid_predictions = grid.predict(X_test)print(confusion_matrix(y_test, grid_predictions)) 123[[17 2 0] [ 0 21 0] [ 0 0 14]] 1print(classification_report(y_test, grid_predictions)) 1234567 precision recall f1-score support 0 1.00 0.89 0.94 19 1 0.91 1.00 0.95 21 2 1.00 1.00 1.00 14avg / total 0.97 0.96 0.96 54 預測效果相比預設參數有大幅改善 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/10/12/ML-course-note-SVM/"},{"title":"Raspberry Pi3 MJPEG-Streamer Install & Setup","text":"材料 Raspberry pi3 / Raspbian ktnet KTCCD323 iWatch 5000萬 網路攝影機 (199元) Install12345678910111213141516# 更新&安裝sudo apt-get updatesudo apt-get upgrade -ysudo apt-get install build-essential libjpeg8-dev imagemagick libv4l-dev cmake -y# Clone Repo 到 /Downloadscd /Downloadsgit clone https://github.com/jacksonliam/mjpg-streamer.gitcd mjpg-streamer/mjpg-streamer-experimental# Makemakesudo make install# 執行/usr/local/bin/mjpg_streamer -i \"input_uvc.so -r 1280x720 -d /dev/video0 -f 30 -q 80\" -o \"output_http.so -p 8080 -w /usr/local/share/mjpg-streamer/www\" Servicepi3 IP : 192.168.1.8http-server IP : 192.168.1.161 1234567891011121314 Web StreamXDD document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/02/02/Raspberry-Pi3-MJPEG-Streamer-Install-Setup/"},{"title":"Logistic Regrassion - 廣告點擊資料分析&預測","text":"Dataset來源: 隨機產生的虛擬資料 Download目標是預測一個使用者是否有點擊廣告 引入函式庫1234import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sns 讀取資料12ad_data = pd.read_csv('advertising.csv')ad_data.head() 欄位說明 ‘Daily Time Spent on Site’: consumer time on site in minutes ‘Age’: cutomer age in years ‘Area Income’: Avg. Income of geographical area of consumer ‘Daily Internet Usage’: Avg. minutes a day consumer is on the internet ‘Ad Topic Line’: Headline of the advertisement ‘City’: City of consumer ‘Male’: Whether or not consumer was male ‘Country’: Country of consumer ‘Timestamp’: Time at which consumer clicked on Ad or closed window ‘Clicked on Ad’: 0 or 1 indicated clicking on Ad 初步資料分析產生年齡的histgram12ad_data['Age'].plot.hist(bins = 30)plt.xlabel('Age') 產生Area Income對Age的joint plot1sns.jointplot(x = 'Age', y = 'Area Income', data = ad_data) 產生 Daily Time spent on site對Age的joint plot(以kde分布表示)1sns.jointplot(x = 'Age', y= 'Daily Time Spent on Site', data = ad_data, kind = 'kde') 產生hue設為’Clicked on Ad’的pairplot1sns.pairplot(ad_data, hue = 'Clicked on Ad') 訓練Logistic Regression 模型從dataset中切分出train data、test data 採用數值資料、’Ad Topic Line’這種字串無法學習，需要data clean將之去除，或者是想辦法轉換成dummy variable 123456from sklearn.model_selection import train_test_splitX = ad_data[['Daily Time Spent on Site', 'Age', 'Area Income', 'Daily Internet Usage', 'Male']]y = ad_data['Clicked on Ad']X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 101) 載入Logistic Regression模型123from sklearn.linear_model import LogisticRegressionlogmodel = LogisticRegression()logmodel.fit(X_train, y_train) 預測與評估輸入test set產生一組預測資料1predictions = logmodel.predict(X_test) 產生分類報告與confusion matrix接著拿出test set的y_test，即所謂實際結果，並用上面的predictions比較，計算出預測成功率 12from sklearn.metrics import classification_report, confusion_matrixprint(classification_report(y_test, predictions)) 1print(confusion_matrix(y_test, predictions)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/10/11/ML-course-note-LogisticRegrassion/"},{"title":"Tensorflow Notebook 1 - Python實作二元線性分類器","text":"Basic - Perceptron生物的神經元，包含樹突(Dendrites)、細胞核(Body)、軸突(Axon) Artificial Neural Network模仿神經元運作 令activation function運算每個input*weight之和若weight皆為0，加入bias避免輸出恆為0的情況 數學式:$$\\sum_{i=0}^{n} w_{i}x_{i} + b$$ Multiple Perceptron Network Input layer real valus from the data Hidden laayer layers in between input and output 3 or more layers is deep network Output layer Final estimate of the output Cost Function Notationy : true valuea : neuron’s prediction 1. Quadratic Cost$$C = \\frac{\\sum (y-a)^{2}}{n}$$ y - a即為error越大的error，則cost越大會造成learning speed下降 2. Cross Entropy$$C = \\frac{-1}{n}\\sum (ylna+(1-y)ln(1-a))$$ error越大則learning speed越快(the larger the difference, the faster the neuron can learn.) ConceptWe need to figure out how we can use our neurons(activation function) and the measurement of error (cost function) and then attempt to correct our prediction (learning) Manual Neural Network以下用python實作一個ANN，並分類一個2個label的資料集(二元線性分類器) Basic Graph “Graph”可想像成一連串nodes，n1、n2為常數輸入，n3為”operation”，繼承此class實作各種運算，例如上圖add operation，最後輸出為3 Python ImplementationOpeartion123456789101112class Operation(): def __init__(self, input_nodes=[]): self.input_nodes = input_nodes self.output_nodes = [] for node in input_nodes: node.output_nodes.append(self) _default_graph.operations.append(self) def compute(self): pass 123456class add(Operation): def __init__(self, x, y): super().__init__([x, y]) def compute(self, val_x, val_y): #overwrite self.inputs = [val_x, val_y] return val_x + val_y 123456class multiply(Operation): def __init__(self, x, y): super().__init__([x, y]) def compute(self, val_x, val_y): #overwrite self.inputs = [val_x, val_y] return val_x * val_y 123456class matmul(Operation): # matrix multiply def __init__(self, x, y): super().__init__([x, y]) def compute(self, val_x, val_y): #overwrite self.inputs = [val_x, val_y] return val_x.dot(val_y) Placeholder1234class Placeholder(): def __init__(self): self.output_nodes = []; _default_graph.placeholders.append(self) Variable123456class Variable(): def __init__(self, initial_value = None): self.value= initial_value self.output_nodes = [] _default_graph.variables.append(self) Graph123456789class Graph(): def __init__(self): self.operations = [] self.placeholders = [] self.variables = [] def set_as_default(self): global _default_graph _default_graph = self 12z = Ax + bA = 10, b = 1 Session此時需要先有post-order traverse function來查看運算是否按照正確順序，比如說這個範例需要先相乘再相加，因此定義session class 12345678910def traverse_postorder(operation): nodes_postorder = [] def recurse(node): if isinstance(node, Operation): for input_node in node.input_nodes: recurse(input_node) nodes_postorder.append(node) recurse(operation) return nodes_postorder 123456789101112131415161718192021class Session(): def run(self, operation, feed_dict={}): # feed_dict to input a batch of data nodes_postorder = traverse_postorder(operation) for node in nodes_postorder: if type(node) == Placeholder: node.output = feed_dict[node] elif type(node) == Variable: node.output = node.value else: #operation node.inputs = [input_node.output for input_node in node.input_nodes] node.output = node.compute(*node.inputs) # args if type(node.output) == list: node.output = np.array(node.output) return operation.output Usage1234567891011121314# example1g = Graph()g.set_as_default()A = Variable(10)b = Variable(1)x = Placeholder()z = add(multiply(A, x), b)sess = Session()result = sess.run(operation = z, feed_dict = {x:10})print(result) #101 123456789101112131415# example2g = Graph()g.set_as_default()# z = Ax + bA = Variable([[10, 20], [30, 40]])b = Variable([1, 2])x = Placeholder()y = matmul(A, x)z = add(y, b)sess = Session()sess.run(operation=z, feed_dict={x:10}) Perceptron type model應用此模型來做分類，從簡單的linear classification開始! Activation function先引入視覺化套件 12import matplotlib.pyplot as plt%matplotlib inline 定義activation function 12def sigmoid(z): return 1 / (1 + np.exp(-z)) 先看看這個function的長相 1234sample_z = np.linspace(-10, 10, 100)sample_a = sigmoid(sample_z)plt.plot(sample_z, sample_a) 建立運算(繼承Operation) 12345class Sigmoid(Operation): def __init__(self, z): super().__init__([z]) def compute(self, z_val): return 1 / (1 + np.exp(-z_val)) Feature之間的線性關係上面我們定義了神經元中的activation function，現在我們要找出feature之間的線性關係，這是我們從資料集中觀察到的結果，是人類自己需要歸納、分析的部分。(source: https://isaacchanghau.github.io/post/activation_functions/) 使用scikit-learn的內建資料集產生器 123from sklearn.datasets import make_blobsfeatures, labels = make_blobs(n_samples = 50, n_features = 2, centers = 2, random_state = 55) 畫出斑點分布 1plt.scatter(features[:, 0], features[:, 1], c=labels) 注意!! 這張圖的兩軸各代表一種feature，顏色代表label 現在，我可以用肉眼觀察，y = x + 5可以很好地劃分2種斑點 1234x1 = np.linspace(0, 11, 10)y1 = x1 + 5plt.scatter(features[:, 0], features[:, 1], c=labels)plt.plot(x1, y1) 接著要實際定義perceptron來構成最簡單的前饋神經網路(Feedforward Neural Network) 前饋神經網路是最早被發明的ANNThe feedforward neural network was the first and simplest type of artificial neural network devised. In this network, the information moves in only one direction, forward, from the input nodes, through the hidden nodes (if any) and to the output nodes. There are no cycles or loops in the network. - Wikipedia Matrix representationy = x + 5其中x,y都是feature可寫成feat2 = feat1 + 5，移項後為-feat1 + feat2 - 5 = 0矩陣表示成 所以給定feat1、feat2，代入上面式子為0代表在y = x + 5線上令$f(feat1, feat2) = -feat1 + feat2 - 5$若$f(feat1, feat2) > 0$表示在直線y = x + 5劃分的上半區域，即label1若$f(feat1, feat2) < 0$表示在直線y = x + 5劃分的下半區域，即label2 因此稱之為linear classification 建構神經元12g = Graph()g.set_as_default() $\\sum_{i} wixi + b$ 1234x = Placeholder()# f(feat1, feat2) = −feat1 + feat2 − 5 w = Variable([-1, 1])b = Variable(-5) activation function:$a = f(\\sum_{i} wixi + b )$ 12z = add(matmul(w, x), b)a = Sigmoid(z) 再複習一次，sigmoid會給我們一個近似0或1的數，類比成神經元的行為就是當輸入訊號到達某個threshold(上圖就是0)，產生電脈衝。電脈衝沿著軸突並通過突觸傳遞到其它神經元 現在我們已經完成神經元的構造，現在我有一組features=(-8, 10)丟進這個perceptron model，看看這個model會辨識出什麼 123sess = Session()sess.run(operation=a, feed_dict={x: [-8, 10]})# 0.99999773967570205 輸出一個很接近1的數，代表label = 1我們可以看到分布圖中(-8, 10)的位置就是直線上半的某點 12sess.run(operation=a, feed_dict={x: [0, -5]})# 4.5397868702434395e-05 輸出一個很接近0的數，代表label = 0 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/12/01/Tensorflow-notebook-1/"},{"title":"FreeRTOS Task Creation 與 Semi-hosting (USART) 設定","text":"通常一個應用可以將個功能切分為多個task，各個task的資料相互傳遞、存取皆可透過FreeRTOS的kernel services完成，本篇紀錄基本的task creation API並設定semi-hosting在eclipse開發環境印出uart傳遞至PC的資料。 我使用的硬體是NUCLEO-F411RE然而只要有對應的port.c就能在不同硬體上使用FreeRTOSdata brief: https://www.st.com/resource/en/data_brief/nucleo-f411re.pdf 每次產生task，FreeRTOS會做以下動作 RTOS的Task可視為作業系統課本提到的process 在context switch時，usStackDepth為stack空間來儲存local variables以及context of task 12345678BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, // 給定該task的stack空間,單位是words void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask // task handler指向TCB位址); task配置在ram記憶體中的heap section 單一task在round robin scheduler的執行模式 設定semi-host STM32 debugger提供semihosting功能，下圖target是arm開發板，只有在debug mode可以使用，讓host的電腦幫我們做printf等指令。 照以下步驟設定 GCC Linker加入參數-specs=rdimon.specs -lc -lrdimon按apply > OK Debug configuration of your application monitor arm semihosting enable In main.c use 12extern void initialise_monitor_handles();initialise_monitor_handles(); Check Exclude for syscalls.c USE SEMIHOSTING Preprocessor在有使用semi-hosting的程式碼加上directives(指示詞)，並按照下圖設置，如果defined symbols的列表中有USE_SEMIHOSTING的話編譯前preporcessor就會包含這個#ifdef的區塊。 1234#ifdef USE_SEMIHOSTING// used for semihostingextern void initialise_monitor_handles();#endif UART Communication with PCUART GPIO Configuration12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static void prevSetupUart(void) { // peripheral related initialization // 1. Enable the UART2 and GPIOA Peripheral clock RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE); RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); // 2. // PA2: UART2_TX // PA3: UART2_RX // Alternate function configuration of MCU pins to behave as UART2 Tx, Rx GPIO_InitTypeDef gpio_uart_pins; memset(&gpio_uart_pins, 0, sizeof(gpio_uart_pins)); // clear the structure gpio_uart_pins.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3; gpio_uart_pins.GPIO_Mode = GPIO_Mode_AF; gpio_uart_pins.GPIO_PuPd = GPIO_PuPd_UP; // for idle state GPIO_Init(GPIOA, &gpio_uart_pins); // 3. AF mode settings for the pins GPIO_PinAFConfig( GPIOA, // PA2 GPIO_PinSource2, // PA2 GPIO_AF_USART2 ); GPIO_PinAFConfig( GPIOA, // PA3 GPIO_PinSource3, // PA3 GPIO_AF_USART2 ); // 4. UART parameter initializations USART_InitTypeDef uart2_init; memset(&uart2_init, 0, sizeof(uart2_init)); // clear the structure uart2_init.USART_BaudRate = 115200; uart2_init.USART_HardwareFlowControl = USART_HardwareFlowControl_None; uart2_init.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; uart2_init.USART_Parity = USART_Parity_No; uart2_init.USART_StopBits = USART_StopBits_1; uart2_init.USART_WordLength = USART_WordLength_8b; USART_Init( USART2, &uart2_init );} 因為IDLE state在UART是高電位(logic 1)所以 gpio_uart_pins.GPIO_PuPd需設成GPIO_PuPd_UP; Create Tasks12345678910111213141516void vTask1_handler(void *params) { while(1){ printMsg(\"Hello, I'm task-1\\r\\n\"); }}void vTask2_handler(void *params) { while(1){ printMsg(\"Hello, I'm task-1\\r\\n\"); }} Result： 交互顯示task-1與task-2的字串，但因為他們的priority一樣，且共用UART data register，所以他們會在資料傳輸中互相preempt，可以用semaphores, mutexes等來保護critical section，以下用簡單的key方法解決。 UART_ACCESS_KEY and taskYIELD() UART_ACCESS_KEY 代表鑰匙，如果鑰匙可取得, 則此task可存取critial section，taskYIELD() api 可以主動觸發context switch並強制task離開CPU, 否則task-2沒有機會取得鑰匙。 12345678910111213141516171819202122232425262728293031323334void vTask1_handler(void *params) { while(1){ if(UART_ACCESS_KEY == AVAILABLE) { UART_ACCESS_KEY = NON_AVAILABLE; printMsg(\"Hello, I'm task-1\\r\\n\"); UART_ACCESS_KEY = AVAILABLE; taskYIELD(); } }}void vTask2_handler(void *params) { while(1){ if(UART_ACCESS_KEY == AVAILABLE) { UART_ACCESS_KEY = NON_AVAILABLE; printMsg(\"Hello, I'm task-2\\r\\n\"); UART_ACCESS_KEY = AVAILABLE; taskYIELD(); } }} Result： source code: https://github.com/syokujinau/ARM_RTOS_Projects/blob/master/RTOS_Workspace/STM32_UART/src/main.c document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/01/07/RTOS-Task-Creation-and-semihosting-settings/"},{"title":"Tensorflow Notebook 2 - Linear Regression","text":"Setup Download Python 3.7 version 勾選新增環境變數 (沒勾就要手動加，不然就開Anaconda Prompt下指令也可) cd到教學資料夾，有tfdl_env.yml檔案 執行conda env create -f tfdl_env.yml 執行activate tfdeeplearning 執行jupyter notebook Basic Training Flow基本流程 建立Graph 初始化Session 丟入data並取得輸出 Linear Regression 1234import numpy as npimport tensorflow as tfimport matplotlib.pyplot as plt%matplotlib inline 12x_data = np.linspace(0,10,10) + np.random.uniform(-1.5,1.5,10) # 加入雜訊y_label = np.linspace(0,10,10) + np.random.uniform(-1.5,1.5,10) 模擬實際資料分布1plt.plot(x_data,y_label,'o') 給定隨機斜率與截距 12m = tf.Variable(0.5) # 隨便給的variable ~b = tf.Variable(0.5) Cost Function如同吳恩達在Linear Regression所講的cost function$$J(\\theta_0, \\theta_1) = \\frac{ 1 }{ 2m } \\displaystyle \\sum_{ i = 1 }^{ m } (\\hat{ y }^{(i)} - y^{(i)})^2 = \\frac{ 1 }{ 2m } \\displaystyle \\sum_{ i = 1 }^{ m } (h_\\theta(x^{(i)}) - y^{(i)})^2 $$ $\\theta_0$是截距b，$\\theta_1$是斜率m $\\hat{ y }$或是$h_\\theta(x)$就是預測的$y$值所以預測與現實的差距$(\\hat{ y } - y)$就是誤差，而平方目的是punish，讓誤差大時累加error更大，並在誤差減少時快速遞減 1234567error = 0for x,y in zip(x_data,y_label): y_hat = m*x + b # hypothesis error += (y_hat - y)**2 梯度下降法最小化Cost Function12optimizer = tf.train.GradientDescentOptimizer(learning_rate=0.001) # learning_rate通常就用0.001train = optimizer.minimize(error) train存的是optimizer傳入cost function(error)回傳的operation，所以之後要丟入session.run() 初始化 Variables1init = tf.global_variables_initializer() Session12345678910111213with tf.Session() as sess: sess.run(init) epochs = 100 # 1個epoch表示跑過train set中所有樣本一次 for i in range(epochs): sess.run(train) final_slope ,final_intercept = sess.run([m,b]) print('%d次epochs的線性回歸函數: y = %.2fx + %.2f ' % (epochs, final_slope, final_intercept))# 100次epochs的線性回歸函數: y = 0.91x + 0.42 Result12345x_test = np.linspace(-1,11,10)y_pred_plot = final_slope * x_test + final_interceptplt.plot(x_test,y_pred_plot,'r')plt.plot(x_data,y_label,'o') 實驗1123456import numpy as npimport pandas as pdimport tensorflow as tfimport matplotlib.pyplot as plt%matplotlib inline 123x_data = np.linspace(0.0, 10.0, 1000000) noise = np.random.randn(len(x_data)) $y = wx + b + noise$ 1y_true = (0.5 * x_data) + 5 + noise 123456789x_df = pd.DataFrame(data=x_data, columns=['X'])y_df = pd.DataFrame(data=y_true, columns=['Y'])my_data = pd.concat([x_df, y_df], axis=1)my_data.head()my_data.sample(n=250).plot(kind='scatter', x='X', y='Y') 12m = tf.Variable(0.5) # random numbersb = tf.Variable(1.0) 12x_ph = tf.placeholder(tf.float32, [batch_size])y_ph = tf.placeholder(tf.float32, [batch_size]) 預測函數:$\\hat{ y } = m * x + b$ 1y_hat = m * x_ph + b 使用tensorflow的API來描述cost function 1error = tf.reduce_sum(tf.square(y_hat - y_ph)) 梯度下降法optimizer 12optimizer = tf.train.GradientDescentOptimizer(learning_rate=0.001)train = optimizer.minimize(error) 初始化graph中的global variables，回傳值是operation 1init = tf.global_variables_initializer() Session: 定義bach size 1234567891011121314batch_size = 8with tf.Session() as sess: sess.run(init) # 每一批丟入8個實際(x, y)值，optimizer會最佳化回歸直線，共做1000次 batches = 1000 for i in range(batches): rand_idx = np.random.randint(len(x_data), size = batch_size) # 回傳隨機8個index值的陣列 feed = {x_ph: x_data[rand_idx], y_ph: y_true[rand_idx]} sess.run(train, feed_dict=feed) final_slope ,final_intercept = sess.run([m,b]) # 記得m,b是上面宣告的tf.Variable() 123y_hat = final_slope * x_data + final_interceptmy_data.sample(250).plot(kind='scatter', x='X', y='Y')plt.plot(x_data, y_hat, 'r') 最後training的結果(圖中紅線) 實驗2 - 使用estimator API123456import numpy as npimport pandas as pdimport tensorflow as tfimport matplotlib.pyplot as plt%matplotlib inline 產生樣本 1x_data = np.linspace(0.0, 10.0, 1000000) 加入雜訊 1noise = np.random.uniform(-2, 2, len(x_data)) $y = wx + b + noise$ 1y_true = (0.8 * x_data) + 3 + noise 畫出模擬的資料分布 12myDataset = pd.concat([pd.DataFrame(data=x_data,columns=['X Data']),pd.DataFrame(data=y_true,columns=['Y'])],axis=1)myDataset.sample(250).plot(kind='scatter',x='X Data',y='Y') 使用estimator API來做訓練123# 首先要設定feature類型、倒入哪種模型，可以想成格式設定feat_cols = [tf.feature_column.numeric_column('x',shape=[1])] estimator = tf.estimator.LinearRegressor(feature_columns=feat_cols) 切分訓練、測試資料123from sklearn.model_selection import train_test_splitx_train, x_eval, y_train, y_eval = train_test_split(x_data,y_true,test_size=0.3, random_state = 101) 丟入樣本，類似之前的feed_dict動作1234input_func = tf.estimator.inputs.numpy_input_fn({'x':x_train},y_train,batch_size=4,num_epochs=None,shuffle=True)train_input_func = tf.estimator.inputs.numpy_input_fn({'x':x_train},y_train,batch_size=4,num_epochs=1000,shuffle=False) # 接受參數，輸出數據訓練數據eval_input_func = tf.estimator.inputs.numpy_input_fn({'x':x_eval},y_eval,batch_size=4,num_epochs=1000,shuffle=False) # 接受參數，並輸出驗證數據和測試數據 Trains a model given training data input_fn 1estimator.train(input_fn=input_func,steps=1000) Evaluation12train_metrics = estimator.evaluate(input_fn=train_input_func,steps=1000)eval_metrics = estimator.evaluate(input_fn=eval_input_func,steps=1000) 1234print(\"train metrics: {}\".format(train_metrics))print(\"eval metrics: {}\".format(eval_metrics))#train metrics: {'average_loss': 1.393801, 'global_step': 1000, 'loss': 5.5752039}#eval metrics: {'average_loss': 1.3947791, 'global_step': 1000, 'loss': 5.5791163} Predictions12345678910111213141516# 假設我們得到一組新的樣本 np.linspace(0, 10, 10)input_fn_predict = tf.estimator.inputs.numpy_input_fn({'x':np.linspace(0,10,10)},shuffle=False)list(estimator.predict(input_fn=input_fn_predict))# fetch resultspredictions = []for x in estimator.predict(input_fn=input_fn_predict): predictions.append(x['predictions'])predictionsmyPredict = pd.concat([pd.DataFrame(data=np.linspace(0,10,10),columns=['New X']), pd.DataFrame(data=predictions,columns=['predictions'])],axis=1)print('my prediction line: y = %.2fx + %.2f' % ((myPredict.iloc[1]['predictions'] - myPredict.iloc[0]['predictions'])/((myPredict.iloc[1]['New X'] - myPredict.iloc[0]['New X'])), myPredict.iloc[0]['predictions'])) 預測函數: $y = 0.81x + 2.75$ 12myDataset.sample(n=250).plot(kind='scatter',x='X Data',y='Y')plt.plot(np.linspace(0,10,10), predictions, 'r') document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/12/04/Tensorflow-notebook-2/"},{"title":"演算法設計 - Divide and Conquer","text":"D&C演算法大致會是以下流程 Split into subproblems Solve subproblems recursively Merge solutions Find MaxMin給一序列$data = \\left [ a_1, a_2, \\dots , a_n \\right ]$只能用pairwise comparison，求這個序列的最大與最小值 Brute force (n-1)次比較找到MAX，(n-2)次比較找到min，共需要$2n - 3$時間 D&C 12345MaxMin(data, 1, n) { [Max1, min1] = MaxMin(data, 1, n/2) [Max2, min2] = MaxMin(data, n/2 + 1, n) return [max(Max1, Max2), min(min1, min2)]} $T(n) = 2T(\\frac{n}{2}) + 2$, 若只有2數只需1次比較$T(2) = 1$ $= \\frac{3}{2}n - 2$ Max Subsequence Sum 給一序列，$data = \\left [ a_1, a_2, \\dots, a_n \\right ]$ 求最大的連續子序列之和，$Max_{i,j} = a_i + a_{i+1} + \\dots + a_{j}$ ex. $\\left [ -5, 12, -3, -4, 15, -6\\right ]$ 其中最大子序列$\\left [ 12, -3, -4, 15\\right ]$，總和為20 $\\left [ -5, 12, -10, -11, 15, -6\\right ]$ 其中最大子序列$\\left [ 15\\right ]$，總和為15 Brute force 約$\\frac{n^{2}}{2}$種不同的子序列，每個序列最多$n$筆資料$\\Rightarrow \\frac{n^{3}}{2} \\in O(n^{3})$ D&C 123456789MaxSubseqSum(data, 1, n) { // 從1~n中，求最大子序列之和 if n = 1, return a1 m1 = MaxSubseqSum(data, 1, n/2) m2 = MaxSubseqSum(data, n/2 + 1, n) m3 = max_i(data, 1, n/2) // 從n/2往前加i個的最大值 O(n) m4 = max_j(data, n/2 + 1, n) // 從n/2 + 1往後加j個的最大值 O(n) return max(m1, m2, m3+m4)} $T(n) = 2T(\\frac{n}{2}) + \\Theta (n)$ $= \\Theta (nlogn)$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/03/13/algorithm-design-divide-and-conquer/"},{"title":"演算法設計 - Greedy Algorithm","text":"Greedy演算法的設計精神 Build a solution in small steps At each step optimize locally Meeting Scheduling給予$M_1, M_2, \\dots, M_n$個會議$M_i$的開會時間從$s_i$到$t_i$求最多可參加幾場會議 Greedy想要盡可能的每一步都取目前最佳解法，並且嘗試證明沒有比這個方法更好的解法，期待而不保證會得到整體最佳解。 以下列出一些可能的greedy解法 $greedy1$. 選離目前$t_i - s_i$最短的 12greedy : |------|optimal: |-------------| |------------| $greedy2$. 選離目前最少衝突的會議 1234 |----| |----| |----| |----|greedy : |----|optimal: |----||-----| |----| |----| $greedy3$. 選離目前最早開始的，即$s_i$最小的 12greedy : |-----------------------------|optimal: |----| |----| |----| $greedy4$. 選離目前最早結束的，即$t_i$最小的 假設存在某個演算法opt的會議數比$greedy4$還多1個 Greedy: $M_1, M_2, M_3, \\dots, M_k$ opt: $M_{1}^{‘}, M_{2}^{‘}, M_{3}^{‘}, \\dots, M_{k}^{‘}, M_{k+1}^{‘}$ 若證明opt有矛盾，就能確定$greedy4$演算法為optimal 上面的取法imply $t_{1} \\leq t_{1}^{‘}$ $t_{k}^{‘} < t_{k}$ 驗證上式是否可能存在$j$，使得 $t_{j} \\leq t_{j}^{‘}$ $t_{j+1} > t_{j+1}^{‘}$ 1234 M_{j} M_{j+1}Greedy: |------------| |------------| M'_{j} M'_{j+1}opt : |-----------| |--------| 此種情況有矛盾，因為$greedy4$應該會選擇$M_j、M_{j+1}^{‘}$，因此證明$greedy4$演算法本身即為optimal Restaurant (Greedy) Groups: $G_1, G_2, \\dots , G_m$ number of people: $a_1, a_2, \\dots , a_m$ dollars per person: $d_1, d_2, \\dots , d_m$(Assume $d_1 \\geq d_2 \\geq \\dots \\geq d_m$) Want: $Max \\sum_{S} a_{i}d_{i}$ , subject to $\\sum_{S} a_{i} \\leq n$ Greedy algorithm pick $G_1, G_2, \\dots, G_k$ until $G_{k+1}$ doesn’t fit $\\sum_{S} a_{i} \\leq n$ (加入$a_{k+1}$座位數剛好不夠) 可能的greedy策略: 因為$d_1 \\geq d_2 \\geq \\dots \\geq d_k \\geq d_{k+1}$，所以選$G_1, G_2, \\dots , G_k$counter example: $m = 2$ $a_1 = 1, d_1 = 100$ $a_2 = n, d_2 = 99$ greedy profit = 100 dollars, opt profit = 99n (better) Pick $max \\begin{cases} G_1, G_2, \\dots , G_k & \\newline G_{k+1} & \\end{cases}$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/04/14/algorithm-design-greedy/"},{"title":"Anki - 使用AwesomeTTS與Japanese Support自動產生振假名與發音","text":"希望能製作一種卡片，看中文可以想到日文，訓練自己的中翻日能力，並且自動產生振假名，好處還有看背面的時候google小姐會唸給你聽增強記憶XD。 Install請先安裝以下2種套件，才能使用他們的功能與樣板 AwesomeTTS Japanese Support 基本日文卡片先來看看由Japanese Support提供的Japanese (recognition)的卡片樣板，可以看到它是根據Expression為Reading欄位加上振假名。 正面: 1 {{Expression}} 樣式: 123456789101112.card { font-family: arial; font-size: 20px; text-align: center; color: black; background-color: white;}.jp { font-size: 30px }.win .jp { font-family: \"MS Mincho\", \"ＭＳ 明朝\"; }.mac .jp { font-family: \"Hiragino Mincho Pro\", \"ヒラギノ明朝 Pro\"; }.linux .jp { font-family: \"Kochi Mincho\", \"東風明朝\"; }.mobile .jp { font-family: \"Hiragino Mincho ProN\"; } 背面: 123456{{FrontSide}} {{furigana:Reading}} {{Meaning}} 加上TTS與振假名功能Step1工具→管理筆記類型→新增，選擇下圖筆記類型 Step2隨意命名筆記名稱，我是叫Japanese - 中翻日TTS 改欄位順序(也可以不改順序)，欄位名稱Expression與Reading不能自己命名，因為這是Japanese Support定義的，到時候分別輸入: Meaning: 中文 Expression: 日文 會根據Expression的漢字產生: Reading: 日文含振假名 AwesomeTTS會唸出Expression(不能唸Reading欄位因為振假名也會被重複地唸出來) Step3選擇Japanese - 中翻日TTS→卡片修改正背面與樣式 欄位名稱會用{}包住，類似mustache樣板字串，然後背面樣板中的Expression用tts tag包住就能發音，此外，因為Reading會顯示日文含振假名，而正面不需要顯示日文，所以在Expression的tag加上hidden來隱藏。 Source code正面: 1234567 {{Expression}} {{Meaning}} 樣式: 12345678910111213.card { font-family: arial; font-size: 20px; /* text-align: center; */ /* 我習慣文字靠左，想要置中就把上面註解拿掉 */ color: black; background-color: white;}.jp { font-size: 30px }.win .jp { font-family: \"MS Mincho\", \"ＭＳ 明朝\"; }.mac .jp { font-family: \"Hiragino Mincho Pro\", \"ヒラギノ明朝 Pro\"; }.linux .jp { font-family: \"Kochi Mincho\", \"東風明朝\"; }.mobile .jp { font-family: \"Hiragino Mincho ProN\"; } 背面: 1234{{Meaning}} {{Expression}} {{furigana:Reading}} Usage中翻日 當然用法不只有中翻日，也可以在Meaning輸入日文意思或圖片 圖翻日 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/02/15/anki-japanese-support-and-awesomeTTS/"},{"title":"演算法設計 - Dynamic Programming","text":"基本設計概念: Solve a pre-determined set of problems Memorize solutions to all subproblems Unique Path走到(i, j)的位置，只有可能來自上面或左邊令$P(i, j)$表示走到(i, j)位置的方法數 $$P(i, j) = \\begin{cases}1 & \\text{ if } i=0 \\newline1 & \\text{ if } j=0 \\newlineP(i-1, j) + P(i, j-1) & \\text{ if } i \\geq 1, j \\geq 1\\end{cases}$$ 又稱為state equation 62. Unique Paths 123456789101112131415161718192021int uniquePaths(int m, int n) { // create a m*n matrix vector P(m); for(int i = 0; i < m; ++i) P[i].resize(n); // init for(int j = 0; j < n; ++j) P[0][j] = 1; for(int i = 0; i < m; ++i) P[i][0] = 1; // update for(int i = 1; i < m; ++i) for(int j = 1; j < n; ++j) P[i][j] = P[i - 1][j] + P[i][j - 1]; return P[m - 1][n - 1];} 時間複雜度: $O(mn)$ Max subsequence sum給予$\\left [ a_{1}, a_{2}, \\dots , a_{n} \\right ]$ 求連續子序列之和的最大值$Max_{i,j} = a_i +a_{i+1} + \\dots + a_{j}$ Subproblem: $R_i$為$\\left [ a_1, a_2, \\dots, a_i \\right ]$的最大子序列之和 $M_i$代表目前的子序列和最大值 Init:$R_1 = a_1$$M_1 = a_1$ $$R_i = max \\begin{cases}R_{i-1} + a_i & \\newlinea_i &\\end{cases}$$ $$M_i = max \\begin{cases}M_{i-1} & \\newlineR_i &\\end{cases}$$ 53. Maximum Subarray 12345678910111213141516int maxSubArray(vector& nums) { const int len = nums.size(); vector M(len); // max subseq so far vector R(len); // R[i] means max subseq (contain ai) // init M[0] = R[0] = nums[0]; // update for(int i = 1; i < len; ++i) { R[i] = max(R[i - 1] + nums[i], nums[i]); M[i] = max(M[i - 1], R[i]); } return M[len - 1];} 時間複雜度: $O(n)$ Optimal Investment Suppose there are $m$ different money investment plans $P_1, P_2,…, P_m$ available, Plan $P_i$ takes $y_i$ years and will increase your money by a factor of $(1+r_i)^{y_i}$. (In other words, if you invest $D$ dollars in plan $P_i$, after $y_i$ years, you will have $D(1+r_i)^{y_i}$ dollars.) For every $i$, $y_i$ is a positive integer and $r_i \\geq 0$. You start with some fixed amount of money $M$ and need to choose a series of plans to invest one by one. You must invest all your money into a single plan at any given time. You must select some plans with the total duration at most $n$ years. The goal is to maximize your money at the end of these investments. The series of plans you choose may include the same plan any number of times. Assume that the annual interest rate $r_i$ satisfies $r_1 \\geq r_2 \\geq … \\geq r_m$ Design an $O(mn)$-time algorithm which finds the final amount of money after the optimal series of investment. 共$n$年，有$m$個plan可選擇 Subproblem: 令$C(i, j)$為max profit，代表只用了$P_1, P_2,…,P_i$的投資組合於$j$年之間，目前狀態下只需考慮要不要不投資$P_i$ $C(i,j) = max \\begin{cases}C(i-1 , j) & \\text{, don’t invest } P_i \\newlineC(i, j-y_i) \\cdot (1+r_i)^{y_i} & \\text{, invest } P_i \\text{ at least once}\\end{cases}$ Algo: 為維持可讀性，先不管陣列超出邊界存取問題因為沒有限定一個plan能投資幾次，所以固定$i$個plan，$1 \\sim n$年都有可能再選擇$P_i$ $\\text{for }i = 1 \\text{ to }m \\text{ plans} \\\\ \\space \\space \\space \\space \\text{for }j = 1 \\text{ to } n \\text{ years} \\\\ \\space \\space \\space \\space \\space \\space \\space \\space C(i,j) = max \\begin{cases} C(i-1 , j) & \\text{, don't invest } P_i \\\\ C(i, j-y_i) \\cdot (1+r_i)^{y_i} & \\text{, invest } P_i \\text{ at least once} \\end{cases} \\\\ \\text{output: }C(m,n)$ Adding an extra restriction that each plan can only be invested at most twice, Also, you are limited to choosing series of at most $t$ plans (Investing in the same plan twice counts as two). Design a polynomial time algorithm which finds the optimal set of plans. Any algorithm which runs in time polynomial in $mnt$ suffices. Subproblem: 令$C(i,j,k)$為max profit，代表 使用$P_1, P_2, \\dots, P_i$ 投資$\\leq j$年 共使用了$\\leq k$個plan $C(i,j,k) = max \\begin{cases} C(i-1 , j,k) & \\text{, don’t invest } P_i \\newline C(i-1, j-y_i, k-1) \\cdot (1+r_i)^{y_i} & \\text{, invest } P_i \\text{ once} \\newline C(i-1, j-2y_i, k-2) \\cdot (1+r_i)^{2y_i} & \\text{, invest } P_i \\text{ twice} \\end{cases}$ Algo: $\\text{for }i = 1 \\text{ to }m \\text{ plans} \\\\ \\space \\space \\space \\space \\text{for }j = 1 \\text{ to } n \\text{ years} \\\\ \\space \\space \\space \\space \\space \\space \\space \\space \\text{for }k = 1 \\text{ to }t \\text{ plans used} \\\\ \\space \\space \\space \\space \\space \\space \\space \\space \\space \\space \\space \\space C(i,j,k) = max \\begin{cases} C(i-1 , j,k) & \\text{, don't invest } P_i \\\\ C(i-1, j-y_i, k-1) \\cdot (1+r_i)^{y_i} & \\text{, invest } P_i \\text{ once} \\\\ C(i-1, j-2y_i, k-2) \\cdot (1+r_i)^{2y_i} & \\text{, invest } P_i \\text{ twice} \\end{cases} \\\\ \\text{output: }C(m,n,t)$ Trip Planning一個旅途$[0, 1, 2, …, n]$，每1km有休息區 起點為$0$ 停在第$i$點的住宿費為$C_i$ 每天只走20km以內 想求得 $0$走到$n$的最小花費 整個旅途中住過哪些休息區 Solution 最後停在$n$，所以必要支出$C_n$ Subproblem: $A[i]$表示可走到$i$的最小花費 紀錄路徑於$B_i$，表示到達$A_i$之前的位置(第$i$公里) init: 前1~20公里最省錢方法就是直接一開始直接到達，B則全部初始化為0 $A[1,2, \\dots ,20] = C[1,2, \\dots ,20]$ $B[i] = 0 \\text{ , where } i = 0 \\sim n$ Algo: $\\text{for i = 21 to n} \\\\ \\space \\space A \\left [ i \\right ] = min(A \\left [ i - 20 \\right ], A \\left [ i - 19 \\right ],...,A \\left [ i - 1 \\right ]) + C_i \\\\ \\space \\space B \\left [i \\right ] = j \\text{ , if the above min pick } A \\left [ j \\right ]$ Resturant DP Groups: $G_1, G_2, \\dots , G_m$ number of people: $a_1, a_2, \\dots , a_m$ dollars per person: $d_1, d_2, \\dots , d_m$ Want: $Max \\sum_{S} a_{i}d_{i}$ , subject to $\\sum_{S} a_{i} \\leq n$ Subproblem: $S(j,k)$ : $Max \\sum_{S} a_{i}d_{i} \\text{, subject to } \\begin{cases} \\sum_{S}a_{i} & \\newline S \\subseteq \\left \\{ G_1, G_2, \\dots, G_{j} \\right \\} & \\end{cases}$ $T(j,k)$ : set of groups selected in $S(j,k)$ $S(j,k) = max \\begin{cases} S(j-1,k- a_j) + a_{j}d_{j} & (\\text{ accept }G_{j}) \\newline S(j-1, k) & (\\text{ don’t accept }G_{j}) \\end{cases}$ $T(j,k) = \\begin{cases} 0 & \\text{ if } T(j-1,k-a_{j}) \\cup \\left \\{ G_{j} \\right \\} (\\text{ accept }G_{j}) \\newline 1 & \\text{ if } S(j-1, k) (\\text{ don't accept }G_{j}) \\end{cases}$ Algo: $\\text{for } j = 1 \\text{ to } m \\\\ \\space \\space \\space \\space \\text{for }k = 1 \\text{ to }n \\\\ \\space \\space \\space \\space \\space \\space \\space \\space S(j,k) = max \\begin{cases} S(j-1,k- a_j) + a_{j}d_{j} & (\\text{ accept }G_{j}) \\\\ S(j-1, k) & (\\text{ don't accept }G_{j}) \\end{cases} \\\\ \\space \\space \\space \\space \\space \\space \\space \\space T(j,k) = \\begin{cases} 0 & \\text{ if } T(j-1,k-a_{j}) \\cup \\left \\{ G_{j} \\right \\} (\\text{ accept }G_{j}) \\\\ 1 & \\text{ if } S(j-1, k) (\\text{ don't accept }G_{j}) \\end{cases} \\\\ \\text{output: }S(m,n), T(m,n)$ Time Complexity: $O(mn)$ Space: $S(j,k)$: $\\Theta (mn)$ $T(j,k)$: $\\Theta (m^{2}n)$ Sequence AlignmentAn application of biology, find the similarity of 2 DNA sequence. Input: X: $ACAAT$ Y: $AGATG$ Let mismatch costs $C_1$, gap costs $C_2$ Output: min cost ex. $ACAAT$ $AGATG$ $\\Rightarrow$ 3 mismatch $ACAAT\\text{ _ }$$AGA\\text{ _ }TG$ $\\Rightarrow$ 1 mismatch, 2 gaps $ACAAT\\text{ _ _ _ _ }$$A\\text{ _ _ _ _ }GATG$ $\\Rightarrow$ 8 gaps Subproblem: $P(i, j)$: min cost of matching “first $i$ symbols of $X$” and “first $j$ symbols of $Y$” ex.$P(3,3)$: min cost of matching $ACA$ and $AGA$$P(1,5)$: min cost of matching $A$ and $ACTAG$ case 1: match $X[i]$ with $Y[i]$ case 2: match $X[i]$ with gap case 3: match $Y[i]$ with gap Subproblem: $P(i,j) = min \\begin{cases} P(i-1, j-1) + \\begin{cases} C_1 & \\text{ if } X[i] \\neq Y[j] \\newline 0 & \\text{ else} \\end{cases} & \\text{ case1 } \\newline P(i-1, j) + C_2 & \\text{ case2 } \\newline P(i, j-1) + C_2 & \\text{ case3 } \\end{cases}$$B(i, j)$: record the cases choosed at $i,j$ Init: match X with an empty Y: $P[i,0] = C_{2}i$ match Y with an empty X: $P[0,j] = C_{2}j$ Algo: $\\text{for } i = 0 \\text{ to } m \\\\ \\space \\space \\space \\space \\text{for } j = 0 \\text{ to } n \\\\ \\space \\space \\space \\space \\\\ \\space \\space \\space \\space \\space \\space \\space \\space P(i,j) = min \\begin{cases} P(i-1, j-1) + \\begin{cases} C_1 & \\text{ if } X[i] \\neq Y[j] \\\\ 0 & \\text{ else} \\end{cases} & \\text{ case1 } \\\\ P(i-1, j) + C_2 & \\text{ case2 } \\\\ P(i, j-1) + C_2 & \\text{ case3 } \\end{cases} \\\\ \\space \\space \\space \\space \\space \\space \\space \\space B(i,j) = \\begin{cases} 1 & \\text{ if choose caes 1 } \\\\ 2 & \\text{ if choose caes 2 } \\\\ 3 & \\text{ if choose caes 3 } \\end{cases} \\\\ \\text{output: }P(m,n)$ Checking $B(m,n)$, we can get the min cost alignment of $X,Y$ $\\text{if } B(m,n) = 1 \\\\ \\space \\space \\text{match } X[m] \\text{ with } Y[n] \\\\ \\space \\space \\text{check } B(m-1,n-1) \\text{ ...etc} \\\\ \\text{if } B(m,n) = 2 \\\\ \\space \\space \\text{match } X[m] \\text{ with } gap \\\\ \\space \\space \\text{check } B(m-1,n-1) \\text{ ...etc} \\\\ \\text{if } B(m,n) = 3 \\\\ \\space \\space \\text{match } Y[n] \\text{ with } gap \\\\ \\space \\space \\text{check } B(m-1,n-1) \\text{ ...etc}$ at most $m+n$ check linear time complexity document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/04/14/algorithm-design-dynamic-programming/"},{"title":"使用 Angstrom Demo Linux Kernel 測試 BeagleBone 開機程序","text":"http://processors.wiki.ti.com/index.php/The_Boot_Process RBL: ROM Boot Loader SPL: Secondary Program Loader MLO: Memory LOder https://stackoverflow.com/questions/27012822/how-mlo-minimal-bootloader-works https://groups.google.com/forum/#!topic/pandaboard/UIwIjwuDddM https://witekio.com/blog/writing-mlo-beagleboard-xm/ 1. Test MLO and U-Boot Ubuntu16.04 on VirtualBox Using GParted to partition microSD card. BOOT - fat16 ROOTFS - ext3 Mark BOOT as bootable Copy MLO, U-boot.img, etc to boot partition [Note] Should contain not only MLO and u-boot.img but all the files, otherwise it cannot read the u-boot correctly. Connect to BBB J1 header pins to PC via USB to TTL Insert the microSD to the SD card slot of BBB Power on the BBB Press and hold the S2 button (BOOT button) Boot source order if S2 button is pressed: SPI0, MMC0, USB0, UART0 Press the S3 button (POWER button) Release the S2 button Correct U-Boot logs Now, we can use u-boot to boot the kernel. 2. Boot Linux Kernel from ROOTFS Mount SD card BOOT copy from here MLO u-boot uEnv ROOTFS copy all files from here [NOTE] Download it by Ubuntu browser [NOTE] Do NOT extract it on Windows which uses a different file system. (I extract it in Windows shared folder, that’s a problem… ) [NOTE] Extract it in command line tar xf archive.tar.xz 3. Get in to Uboot Prompt and print memory content Press RESET button on board Keep pressing the space key Enter help to list all commands Enter load mmc 0:2 0x82000000 /boot/uImage MMC0 interface: microSD card 0:2 means mmc0 2nd partition, 0x82000000 of DDR MMC1 interface: eMMC Load command To load FAT based file system in to memory, use fatload To load a file from any file system, use load uImage has $8645240$ bytes, we can validate it by decode the image header from DDR memory (RAM) Decode image header (64bytes), dump RAM 4 * 4 bytes start from 0x82000000, type md 0x82000000 4 Image data size is 0x0083EA38 and image header is $64$ bytes, in decimal $8645176$, $8645176 + 64 = 8645240$ bytes print header information, type imi 0x82000000 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/10/08/beaglebone-boot-process/"},{"title":"Arduino與FreeRTOS - 簡介與Multual exclusion 解決方法","text":"RTOS一般談到OS常見像是Windows、macOS、Linux等等，稱為General Purpose OS，RTOS全名是Real-time Operating System，實時作業系統，FreeRTOS是個開源的RTOS作業系統，主要支援ARM系列微控制器，各個MCU vendor皆有對應的版本(主要在port.c定義)。 RTOS必須對每個執行的critical operation有一個已知的maximum time，並能做到 處理 interrupts 與 internal system exceptions 維護 Critical Sections 執行合適的 Scheduling Mechanism RTOS中事件觸發到能夠進入CPU的時間(Task switching latency)是定值，所以能夠在有限時間執行重要工作，並且IRQ觸發生到進入ISR的時間極短(Interrupt latency)，例如汽車中的安全氣囊，車禍發生，感應器偵測到衝擊(IRQ occurs)瞬間到使氣囊充氣(ISR handles)必須非常迅速才能有效保護車內人員。個人認為real-time涵義上，主要表達Task的執行是predictable，而非執行速度快(這應是由 clock 決定)。 Download在Arduino下載並使用FreeRTOS非常容易，在Library Manager搜尋安裝即可，並提供一些範例可以直接執行。 Usage一般Arduino的架構會用所謂polling做所有的工作，一個setup做硬體資源設定(啟用UART、設定GPIO等等)，並用一個loop執行一堆東西，基本上就是一個single thread的程式，Arduino常用的delay(1000)就是一個浪費CPU資源的指令，因為你的Arduino這時候只是發呆個1秒左右，才做其他指令，使用multi-thread好處是提高cpu utilization，我們可以create多個task，並在task handler做各種不同的工作。 Task Arduino FreeRTOS Github - tasks.c 可以視為Thread，RTOS預設採用priority based pre-emptive scheduling(可在FreeRTOSConfig.h裡面修改設定)來對多個task做排程，在一個task產生時，RTOS會做以下幾件事 在RAM的system heap產生task control block並初始化 在system heap產生這個task專用的stack (所以需要宣告stack deep) FreeRTOS的kernel service (Task、Queue、Semaphore, etc)都要消耗Arduino的heap記憶體空間 放進ready list 等待排程 task status參考: https://www.freertos.org/RTOS-task-states.html 來看看create一個task需要哪些參數。 12345678BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, // task handler const char * const pcName, // task 名稱 const configSTACK_DEPTH_TYPE usStackDepth, // task所需stack size void * const pvParameters, UBaseType_t uxPriority, // task的優先權 TaskHandle_t * const pxCreatedTask // placeholder); 做個實驗來讓2個優先權相同的task透過UART傳送資料到電腦 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include // prototypesvoid Task1(void *params) ;void Task2(void *params) ; void setup() { Serial.begin(9600); xTaskCreate( Task1, (const portCHAR *) \"Task 1\", 128, // Stack size NULL, 1, // Priority NULL ); xTaskCreate( Task2, (const portCHAR *) \"Task 2\", 128, // Stack size NULL, 1, // Priority NULL ); }void loop() {}void Task1(void *params) { while(1) { Serial.println(\"Task 1\"); } }void Task2(void *params) { while(1) { Serial.println(\"Task 2\"); } } 輸出結果將會是一團糟 這是因為 UART 的 data register 是 Critical section ，也就是具有multual exclusion性質的記憶體資源，好比你家廁所，一次只能有一個人使用，應該不會有人想跟人共用廁所吧= =|||，於是我們可以加裝門鎖，廁所有人用的時候鎖住，就可以避免這種問題。一般具有multual exclusion性質的資源像是global variable、MCU周邊(GPIO、UART、SPI、I2C等等)，這時候mutex、semaphore等等kernel service就派上用場。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include #include // prototypesvoid Task1(void *params) ;void Task2(void *params) ;SemaphoreHandle_t xSerialSemaphore;void setup() { Serial.begin(9600); vSemaphoreCreateBinary(xSerialSemaphore); if(xSerialSemaphore != NULL) { // 如上面所說，semaphore會占用system heap， // 所以要確認他有沒有成功allocated xSemaphoreGive(xSerialSemaphore); // 一開始給出鑰匙 xTaskCreate( Task1, (const portCHAR *) \"Task 1\", 128, // Stack size NULL, 1, // Priority NULL ); xTaskCreate( Task2, (const portCHAR *) \"Task 2\", 128, // Stack size NULL, 1, // Priority NULL ); } else { Serial.println(\"Semaphore creation failed...\"); } }void loop() {}void Task1(void *params) { while(1) { xSemaphoreTake(xSerialSemaphore, portMAX_DELAY ); Serial.println(\"Task 1\"); xSemaphoreGive(xSerialSemaphore); vTaskDelay(pdMS_TO_TICKS(10)); // 強制進入block status以免該task又馬上取得鑰匙 } }void Task2(void *params) { while(1) { xSemaphoreTake(xSerialSemaphore, portMAX_DELAY ); Serial.println(\"Task 2\"); xSemaphoreGive(xSerialSemaphore); vTaskDelay(pdMS_TO_TICKS(10)); } } vTaskDelay(1000) 是daley 1000個ticks，可以用 pdMS_TO_TICKS(1000) 換算1000 ms所需的tick數 Binary Semaphore v.s. Mutex常搞混的mutex與binary semaphore，上面的應用的確也能使用mutex來保護critical section，先簡單說，binary semaphore還是可能出現priority inversion的情況，這是RTOS應該避免的，mutex有實作priority inheritance機制(缺點是要比較多記憶體maintain mutex)，繼承higher priority來最小化priority inversion的發生，有空在寫一篇詳細討論吧(會這樣講就是沒空…) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/09/10/arduino-freeRTOS-semaphore/"},{"title":"Fackbook Bot Webhook架設筆記","text":"當時參加2018 NASA Hackathon做的Facebook聊天機器人，雖然沒得名，但是學會了FB Bot製作、後端database串接，base64 等等還算是有收穫 呵呵 官方 快速入門教學課程 FB Developers 基本上照著做即可 Note 過程中要記得安裝request套件 在開發者頁面要把VERIFY_TOKEN填入(自己記得就好)，對應到的code的VERIFY_TOKEN 3. 在 Messenger 設定主控台的「權杖產生」區段，點擊「選擇粉絲專頁」下拉式功能表，然後選擇您要這個應用程式訂閱的 Facebook 粉絲專頁。這個粉絲專頁就是當用戶在 Messenger 與其交談時，想要 Webhook 接收事件的粉絲專頁4. 要訂閱這個粉專!!!5. 要使這個應用程式上線，需要有隱私權政策網址，可以用產生器產生6. 要提交pages_messaging功能才能讓開發者以外的人使用訊息7. 提交審查之前，要先上傳1024x1024 pixel的透明背景圖，以及勾選商業用途 Ref:http://animabeautifullife.blogspot.com/2016/06/facebook-messenger-api.html Ngrok省去webhook在app engine或heroku等等平台部屬的時間，等debug完成再部屬(記得更改webhook網址)，加速開發! Reference: https://blog.techbridge.cc/2018/05/24/ngrok/ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294'use strict';const myToken = 'YOUR TOKEN';// Imports dependencies and set up http serverconst express = require('express'), bodyParser = require('body-parser'), app = express().use(bodyParser.json()); // creates express http serverconst request = require('request');const image2base64 = require('image-to-base64'); //upload base64 encode image on firebase// Sets server port and logs message on successapp.listen(process.env.PORT || 3000, () => console.log('webhook is listening'));app.get('/', (req, res) => { res.send(`hello yc!!!`);})//1// Creates the endpoint for our webhook app.post('/webhook', (req, res) => { // Parse the request body from the POST let body = req.body; // Checks this is an event from a page subscription if (body.object === 'page') { // Iterates over each entry - there may be multiple if batched body.entry.forEach(function(entry) { // Gets the message. entry.messaging is an array, but // will only ever contain one message, so we get index 0 let webhook_event = entry.messaging[0]; console.log(webhook_event); // Get the sender PSID let sender_psid = webhook_event.sender.id; console.log('Sender PSID: ' + sender_psid); // Check if the event is a message or postback and // pass the event to the appropriate handler function if (webhook_event.message) { // handleMessage(sender_psid, webhook_event.message); switch(webhook_event.message.text) { case 'hi': webhook_event.message.text = 'Hi :))'; handleMessage(sender_psid, webhook_event.message); break; default: //直接回覆原字串 或傳入attachment handleMessage(sender_psid, webhook_event.message); } } else if (webhook_event.postback) { handlePostback(sender_psid, webhook_event.postback); } }); // Returns a '200 OK' response to all requests res.status(200).send('EVENT_RECEIVED'); } else { // Returns a '404 Not Found' if event is not from a page subscription res.sendStatus(404); } });//2// Adds support for GET requests to our webhookapp.get('/webhook', (req, res) => { console.log('get webhook'); // Your verify token. Should be a random string. let VERIFY_TOKEN = \"12345\" //對應到FB developer頁面的驗證權杖 // Parse the query params let mode = req.query['hub.mode']; let token = req.query['hub.verify_token']; let challenge = req.query['hub.challenge']; // Checks if a token and mode is in the query string of the request if (mode && token) { // Checks the mode and token sent is correct if (mode === 'subscribe' && token === VERIFY_TOKEN) { // Responds with the challenge token from the request console.log('WEBHOOK_VERIFIED'); res.status(200).send(challenge); } else { // Responds with '403 Forbidden' if verify tokens do not match res.sendStatus(403); } }});// Handles messages eventsfunction handleMessage(sender_psid, received_message) { let response; // Checks if the message contains text if (received_message.text) { // Create the payload for a basic text message, which // will be added to the body of our request to the Send API response = { //\"text\": `You sent the message: \"${received_message.text}\". Now send me an attachment! \\nfrom handleMessage` \"attachment\": { \"type\": \"template\", \"payload\": { \"template_type\": \"generic\", \"elements\": [{ \"title\": \"Title test\", \"subtitle\": `subtitle`, \"image_url\": '', \"buttons\": [ { \"type\": \"web_url\", \"url\": 'www.google.com', \"title\":\"Google\" } ], }] } } } } else if (received_message.attachments) { // Get the URL of the message attachment let attachment_url = received_message.attachments[0].payload.url; // console.log(`[XDDDDDDD] ${JSON.stringify(received_message.attachments, undefined, 4)}`); response = { \"attachment\": { \"type\": \"template\", \"payload\": { \"template_type\": \"generic\", \"elements\": [{ \"title\": \"回報系統\", \"subtitle\": `25.024782°N 121.528864°E`, \"image_url\": attachment_url, \"buttons\": [ { \"type\": \"web_url\", \"url\": NASAwebpage, \"title\":\"火災現況\" } ], }] } } } const FirebaseURL = 'https://nasa-hackthon-linebot.firebaseio.com/firespot.json'; image2base64(attachment_url) // you can also to use url .then((response) => { let MyData = JSON.stringify({ img : response, location: { latitude: 121.528864, longitude: 25.024782 }, status: \"未通報\" }) request({ \"uri\": FirebaseURL, \"method\": \"POST\", \"body\" : MyData }, (err, res, body) => { if (!err) { //console.log(res); } else { console.log(err); } }); }) .catch((error) => { console.log(error); //Exepection error.... }); } // Send the response message callSendAPI(sender_psid, response); }// Handles messaging_postbacks eventsfunction handlePostback(sender_psid, received_postback) { let response; // Checks if the message contains text if (received_message.text) { // Creates the payload for a basic text message, which // will be added to the body of our request to the Send API response = { \"text\": `You sent the message: \"${received_message.text}\". Now send me an attachment! \\nfrom handlePostback` } } else if (received_message.attachments) { // Gets the URL of the message attachment let attachment_url = received_message.attachments[0].payload.url; } // Sends the response message callSendAPI(sender_psid, response); }function callSendAPI(sender_psid, response) { // Construct the message body let request_body = { \"recipient\": { \"id\": sender_psid }, \"message\": response } // Send the HTTP request to the Messenger Platform request({ \"uri\": \"https://graph.facebook.com/v2.6/me/messages\", \"qs\": { \"access_token\": myToken }, //PAGE_ACCESS_TOKEN \"method\": \"POST\", \"json\": request_body }, (err, res, body) => { if (!err) { console.log('message sent!') } else { console.error(\"Unable to send message:\" + err); } }); }// playgroundasync function getLatestInfo() { // Promise let year = new Date().getFullYear() let month = new Date().getMonth() + 1 let date = new Date().getDate() month = (month < 10)? '0'+month : month; date = (date < 10)? '0'+date : date; return new Promise((resolve, reject) => { request({ \"uri\": `https://launchlibrary.net/1.3/launch/${year}-${month}-${date}`, \"method\": \"GET\", \"json\": true }, (err, res, body) => { if (!err) { // console.log(`[QUERY] ${year}-${month}-${date}`) // console.log(body.launches[0]) let latest = body.launches[0]; resolve({ date: latest.windowstart, name: latest.name, lat: latest.location.pads[0].latitude, lng: latest.location.pads[0].longitude, gmap: latest.location.pads[0].mapURL }) // console.log(data); } else { reject(\"Unable to send message:\" + err); } }); })}/*Usage:getLatestInfo().then((res) => { // handle }).catch((err) => { // error })*/var fbIDtoTimestamp = (id) => { var PUSH_CHARS = \"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\"; id = id.substring(0,8); var timestamp = 0; for (var i=0; i < id.length; i++) { var c = id.charAt(i); timestamp = timestamp * 64 + PUSH_CHARS.indexOf(c); } return timestamp;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/10/22/bulid-a-facebook-bot/"},{"title":"CentOS架設Jupyter notebook server","text":"Step1: 新增CentOS使用者12345sudo adduser jpynbsudo supasswd jpynbgpasswd -a jpynb wheel #給予使用者 sudo 權限lid -g wheel 之後就能用該組帳號密碼ssh進入/home/jpynb Step2: 安裝jupyter12345sudo yum install python-pipsudo yum install python3-pipsudo pip install ipython[all]sudo pip3 install ipython[all] 這時輸入以下指令，初步測試是否安裝成功 1jupyter notebook --no-browser Step3: Config與自製憑證1jupyter notebook --generate-config 進入ipython介面設定密碼 12345ipythonIn[1]: from notebook.auth import passwdIn[2]: passwd()# 輸入exit()退出ipython 這時會輸出一個sha1加密的密碼Out[2]: 'sha1:XXXXXXXXXXXXXXXXXXX' 修改/home/jpynb/.jupyter/jupyter_notebook_config.py 1vim /home/jpynb/.jupyter/jupyter_notebook_config.py 新增下面幾行 123456c.NotebookApp.password = 'sha1:XXXXXXXXXXXXXXXXXXX'c.NotebookApp.port = 8888c.NotebookApp.ip = '0.0.0.0' c.NotebookApp.open_browser = Falsec.NotebookApp.certfile = '/home/jpynb/.jupyter_keys/jcert.pem'c.NotebookApp.keyfile = '/home/jpynb/.jupyter_keys/jkey.key' Note: 有些教學文寫c.NotebookApp.ip = ‘*’來允許任何ip連線，但是會有問題，用’0.0.0.0’可以解決 新增資料夾存放自製憑證的key 123mkdir .jupyter_keyscd .jupyter_keysopenssl req -x509 -nodes -days 365 -newkey rsa:4096 -keyout jkey.key -out jcert.pem 之後cd ..回到home/jpynb Step4: 防火牆設定12sudo firewall-cmd --zone=public --add-port=8888/tcp --permanentsystemctl restart firewalld.service Note: iptables跟firewallId不能同時使用，可以參考CentOS Linux 7 以 firewalld 指令設定防火牆規則教學來更改設定 Step5: 使用Screen背景執行現在輸入jupyter notebook就可以執行了，但是把ssh連線關掉它就會跟著shutdown 1screen 進入screen之後，執行jupyter notebook然後按Ctrl + a再按d就可以detach之後用screen -ls查看screen號碼，輸入screen -r 就能重新進入screen Step6: 安裝Anaconda因為python3 kernal一直裝不起來，所以我直接裝anaconda 參考https://linuxize.com/post/how-to-install-anaconda-on-centos-7/ 123cd /tmpcurl -O https://repo.anaconda.com/archive/Anaconda3-5.3.1-Linux-x86_64.shsha256sum Anaconda3-5.3.1-Linux-x86_64.sh 這時會輸出一個sha256的編碼，到這個網頁查看是否有對應 1bash Anaconda3-5.3.1-Linux-x86_64.sh 接著就一直按Enter跟yes(也會問你要不要裝VScode，不是必要就不裝) 1source ~/.bashrc Note: 如果出現conda: command not found，參考這篇stackoverflow的解答 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/03/03/centOS-jupyter-notebook-server/"},{"title":"計算複雜度理論簡介","text":"主要介紹 P NP NP-Complete Decision Problem一個計算問題，輸出只有True/False的某種演算法例如: 給定一個圖$G$，是否連通? shortest problem也可以改寫成Decision Problem 給定一個圖$G$，兩點$u、v$，且它們的cost為$k$，是否存在一個path，其cost小於$k$? 經典的計算難題: Hamiltonian path、cycle - pass all vertices exactly once 給定一個圖$G$與起點$s$是否存在一個path、cycle，能夠剛好經過所有頂點一次? $P$ Problems一個Decision Problem屬於$P$，若且唯若存在一個poly-time演算法$A(s)$使得 一個instance $s$是true$\\Leftrightarrow A(s) = 1$ 一個instance $s$是false$\\Leftrightarrow A(s) = 0$ 所謂instance可以當作演算法的input，例如Hamiltonian path的instance就是一個graph $NP$ ProblemsNondeterministic Polynomial Time一個Decision Problem屬於$NP$，若且唯若存在一個執行在$poly(\\left | s \\right |)$時間的演算法$B(s, t)$，使得 一個instance $s$是true$\\Leftrightarrow \\exists t, B(s, t) = 1$ 一個instance $s$是false$\\Leftrightarrow \\forall t, B(s, t) = 0$ $\\left | s \\right |$代表輸入instance的個數 $t$是一個random bit可想成丟銅板，若input是true，至少存在一個演算法的output是true，但input是false則所有output皆須是0 答案是true，存在某個$t$使答對機率$> 0$ 答案是false，對所有$t$使答對機率$=100%$ Thm: INDEPENDENT SET $\\in$ $NP$給定無向圖$G=(V,E)$與常數$k$，$G$中是否有一個size為$k$的independent set? independent set: 一組兩兩不相鄰的頂點集合 pf: Construct algo $B(s,t)$ 給定任何instance $s$，也就是$G=(V,E)$，constant $k$ $B(s,t)$ If $\\left | t \\right | \\neq \\left | v \\right |$ True $\\Rightarrow$ 0 False $\\Rightarrow$ 1 If 「# of 1 in $t$」 $\\neq k$ True $\\Rightarrow$ 0 False $\\Rightarrow$ 1 If $t[i] = t[k] = 1$, but $(i,j) \\in E$ True $\\Rightarrow$ 0 False $\\Rightarrow$ 1 Thm: $X \\in P \\Rightarrow X \\in NP$pf: $X \\in P \\Rightarrow \\exists$ poly-time Algo. $A(s)$ Let $B(s,t) = A(s)$ $\\forall t$$\\Rightarrow X \\in NP$ $NP-complete$ Problems一個Decision Problem $X$屬於$NP$，若且唯若 $X \\in NP$ for all $Y \\in NP$，$Y$ is poly-time reducible(改寫) to $X$ reducible意思是能mapping成另一個更難的問題，使得輸入與對應的輸出相同 Thm: HAM. PATH is poly-time reducible to HAM. CYCLEpf: 把HAM. PATH的instance $G$ reduce為$G^{‘}$，方法是在原有的vertex各拉一條edge到一個新的vertex Thm: HAM. PATH $\\in$ $NP-complete$, then the HAM. CYCLE $\\in$ $NP-complete$pf: 若從某個已知是$NP-complete$問題$Y$可以poly-time reduce到HAM. PATH，則也能間接證明HAM. CYCLE也是$NP-complete$ 證明某問題為$NP-complete$的方法$X$: new problem$Y$: old problem，已知為$NP−complete$ 如果符合以下三個條件 $X \\in NP$ $Y \\in NP-complete$ $Y$ is poly-time reducible to $X$ 則可證明 Problem $X \\in NP-complete$ Fisrt $NP-complete$ problem由Cook Levin於1971年證明The Satisfiability Problem (SAT)屬於$NP-complete$，可以由這個問題當作$Y$ problem，並於poly-time reduce成某個新的$X$ problem，使這兩種演算法輸出皆相同，即證明$X$ problem也是$NP-complete$ SAT問題如下(舉例): Given a logic statement of the form $(x_1 + x_2 + \\overline{x_3}) \\cdot (x_2 + x_4) \\cdot (\\overline{x_2} + x_4)$, can we assign each $x_i$ to true/false s.t. the statement is true? 註: 每個括號稱為clause，如果一個clause包含3個以下的變數，則此問題稱為$3SAT$ 證明 INPED. SET $\\in NP-complete$INPED. SET敘述: Given a graph $G = (V,E)$ and a constant $k$, are there $k$ vertices in $G$ s.t. no edges between them. $X \\in NP$ INDEP. SET $\\in NP$ $Y \\in NP-complete$ SAT $\\in NP-complete$ $Y$ is poly-time reducible to $X$ Reduction: 對每個變數$x_i$、$\\overline{x_i}$皆用頂點表示 同一個clause中的變數彼此用一條邊連接 對$x_i$、$\\overline{x_i}$之間用一條邊連接 令$k$為clause的個數 將$x_1 = 1、x_2=1、x_4 = 1$代回$(x_1 + x_2 + \\overline{x_3}) \\cdot (x_2 + x_4) \\cdot (\\overline{x_2} + x_4)$輸出也是True INPED. SET $\\in NP-complete$得證 證明 VERTEX COVER $\\in NP-complete$ A vertex cover $S$ is a set of vertices s.t. $\\forall (u,v) \\in E$ either $u \\in S$ or $v \\in S$ Given a graph $H$, constant $l$, does $H$ have a vertex cover of size $l$? e.g. $H$: $S = \\left \\{ b,c,d,f,g \\right \\}, l = 5$ 以下為證明流程: $X \\in NP$ VERTEX COVER $\\in NP$ (Trivial) $Y \\in NP-complete$ INDEP. SET $\\in NP-complete$ $Y$ is poly-time reducible to $X$ Reduction $f$: $f:$ $H=G$ $l = \\left | V \\right | - k$ Notice that $f$ should be poly-time in “size of $G,k$” 每個邊至少會有一個edge在VERTEX COVER Set之中，暗示這個Set之外的vertex pair皆不相鄰 證明 SET COVER $\\in NP-complete$ Given a set $U = \\{ x_1,x_2,\\dots,x_m \\}$$n$ subsets $S_1、S_2、\\dots、S_n \\subseteq U$constant $k$Are there $k$ subsets such that the union of these $k$ subsets is $U$? e.g. $U= \\{x_1, x_2, x_3, x_4 \\} \\\\$ $n=3$ subsets $S_1 = \\{x_1, x_2 \\} \\\\ S_2 = \\{ x_2,x_3,x_4 \\} \\\\ S_3 = \\{ x_3,x_4 \\}$ $k=2$，是否有2個subsets的union會是$U$? $X \\in NP$ SET COVER $\\in NP$ (Trivial) $Y \\in NP-complete$ VERTEX COVER $\\in NP-complete$ $Y$ is poly-time reducible to $X$ Reduction $f$: $f:$ $U=E$ $S_i = \\{ e | e \\text{ is connected to }v_i \\}$ $k=l$ e.g. $U = \\{ x_1, x_2, x_3, x_4, x_5 \\} \\\\ S_1 = \\{ x_1, x_2 \\} \\\\ S_2 = \\{ x_1 , x_2 \\} \\\\ S_3 = \\{ x_2 , x_3 , x_4 \\} \\\\ S_4 = \\{ x_5 \\} \\\\ S_5 = \\{ x_4 , x_5 \\}$ Are there $k$ subsets such that the union of these $k$ subsets is $U$? document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/05/31/computational-complexity-theory/"},{"title":"用生活化的例子解釋HTTPS","text":"試想一個簡單的情境，Alice跟Bob想互相用飛鴿傳書寄信，但是送信過程可能被Mallory攔截下來偷看內容… 方法一，使用凱薩密碼(Caesar cipher，推移字母替代原文，知道加密方法就能解密，所以屬於對稱式加密)，這時Alice跟Bob想先傳送這個密碼，但是Mallory會攔截，然後就能解碼Alice跟Bob的信件內容，除非Alice跟Bob先私下見面制定密碼。 方法二，當Bob想寄信給Alice，Bob先傳一隻不帶訊息的鴿子，Alice在讓鴿子帶上沒上鎖的盒子，自己留著盒子的鑰匙，然後傳給Bob，Bob收到沒上鎖的盒子後，放入信件並鎖上，傳回給Alice，這時候如果鴿子被攔截，Mallory也無法打開，因為只有Alice有這個盒子的鑰匙，這就是所謂的公鑰與私鑰，雖然叫做公鑰，但是作用是盒子，打開盒子的叫做私鑰。 Q: 當Bob想傳訊息給Alice，如何確定這個盒子來自Alice?A: Alice在盒子上簽名。Q: 這時候問題又來了，Bob怎麼認得這個簽名是Alice的，而不是Mallory偽造的?A: 這時候交給公正的第三方Ted來負責簽名。 Ted是公正的第三方，他的簽名為大家所認可，而且Ted知道這個盒子是Alice請他簽名的，所以Mallory不能攔截盒子然後再請Ted簽名。 Ted就是所謂的Certification Authorities。 雖然Alice與Bob有了安全的方法寄信，這時候他們發現每次都要經過這麼麻煩的程序，所以他們決定在寄信前用盒子傳凱薩密碼(方法二)，這樣他們就不用私下見面制定密碼了，然後之後傳訊息都透過凱薩密碼(方法一)加解密即可。這就是HTTPS運作的概念，只是跑這些流程的速度比鴿子快多了而已。 原文來自HTTPS explained with carrier pigeons document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/03/02/how-https-works/"},{"title":"Imgur upload API 上傳圖片","text":"註冊應用程式https://api.imgur.com/oauth2/addclient 勾選 OAuth 2.0 without callback URL然後就會有Client ID Source codeHTML123 JS123456789101112131415161718192021222324252627282930313233343536373839404142$(\"document\").ready(function () { $('input[type=file]').on(\"change\", function () { var $files = $(this).get(0).files; var formData = new FormData(); formData.append(\"image\", $files[0]); if ($files.length) { // Reject big files if ($files[0].size > $(this).data(\"max-size\") * 1024) { console.log(\"Please select a smaller file\"); return false; } var apiUrl = 'https://api.imgur.com/3/image'; var apiKey = 'Your Client ID'; var settings = { async: true, crossDomain: true, url: apiUrl, method: \"POST\", datatype: \"json\", headers: { Authorization: \"Client-ID \" + apiKey }, processData: false, contentType: false, data: formData, beforeSend: function () { console.log(\"uploading...\"); }, success: function (res) { $('body').append(''); }, error: function () { alert(\"upload failed\"); } } $.ajax(settings).done(function (res) { console.log(\"Done\"); }); } });}); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/02/10/imgur-upload/"},{"title":"Introduction to Asymptotic Notation and Analysis of Algorithms","text":"Big-O: $O$ $$ O(g(n)) = \\left \\{ f(n) \\space | \\space \\exists c, n_0 > 0, \\space s.t. f(n) \\leq c \\cdot g(n) \\space \\space , \\forall n \\geq n_0 \\right \\} $$ Omega: $\\Omega$ $$ \\Omega (g(n)) = \\left \\{ f(n) \\space | \\space \\exists c, n_0 > 0, \\space s.t. f(n) \\geq c \\cdot g(n) \\space \\space , \\forall n \\geq n_0 \\right \\} $$ Theta: $\\Theta$ $$ \\Theta (g(n)) = \\left \\{ f(n) \\space | \\space \\exists c_1, c_2, n_0 > 0, \\space s.t. c_1 \\cdot g(n) \\leq f(n) \\leq c_2 \\cdot g(n) \\space \\space , \\forall n \\geq n_0 \\right \\} $$ little-o: $o$ $$ o(g(n)) = \\left \\{ f(n) \\space | \\space \\forall c > 0, \\exists n_0 > 0, \\space s.t. f(n) \\leq c \\cdot g(n) \\space \\space , \\forall n \\geq n_0 \\right \\} $$ little-omega: $\\omega$ $$ \\omega (g(n)) = \\left \\{ f(n) \\space | \\space \\forall c > 0, \\exists n_0 > 0, \\space s.t. f(n) \\geq c \\cdot g(n) \\space \\space , \\forall n \\geq n_0 \\right \\} $$ PropertiesTransitivity$f(n) \\in O(g(n)), \\space g(n) \\in O(h(n))$ then $f(n) \\in O(h(n))$ True if $O、 \\Omega 、 \\Theta 、 o 、 \\omega$ Prove that $f(n) \\in O(g(n)), \\space g(n) \\in O(h(n)) \\Rightarrow f(n) \\in O(h(n))$$\\because f(n) \\in O(g(n)) \\therefore \\exists c_1, n_1, s.t. f(n) \\leq c_1 g(n), \\space \\forall n \\geq n_1$ $\\because g(n) \\in O(h(n)) \\therefore \\exists c_2, n_2, s.t. g(n) \\leq c_2 h(n), \\space \\forall n \\geq n_2$ where $n \\geq max(n_1, n_2)$, let $max(n_1, n_2) = n_0$ $f(n) \\leq c_1 g(n) \\leq c_1 \\cdot c_2 h(n)$, let $c_1 \\cdot c_2 = c > 0$ $\\Rightarrow f(n) \\leq c \\cdot h(n) \\space \\forall n \\geq n_0$ $\\therefore f(n) \\in O(h(n))$ Prove that $f(n) \\in o(g(n)), g(n) \\in o(h(n)) \\Rightarrow f(n) \\in o(h(n))$ 需先定出$c_1, c_2$否則$n_1, n_2$會隨$c_1, c_2$變化，所以不能用$Big-O$的方法證明 Want to prove: $f(n) \\in o(h(n))$Need: $\\forall c >0$, let $c_1 = 2, c_2 = \\frac{C}{2}$ (只要$c_1 \\times c_2 = c$即可) $f(n) \\in o(g(n)) \\Rightarrow \\exists n_1 > 0, \\space s.t. \\space f(n) \\leq c_1 g(n), \\space \\forall n \\geq n_1$ 其中$n_1$是$c_1$的函數 $\\Rightarrow n_1(c_1)$，這也是需要固定$c_1、c_2$的原因 $g(n) \\in o(h(n)) \\Rightarrow \\exists n_2 > 0, \\space s.t. \\space g(n) \\leq c_2 h(n), \\space \\forall n \\geq n_2$ When $n \\geq max(n_1, n_2), \\space f(n) \\leq c_1 \\cdot g(n) \\leq c_1 \\cdot c_2 h(n)$ let $c_1 \\cdot c_2 = c > 0$ $\\exists n_0 > 0, \\space s.t. f(n) \\leq c \\cdot h(n), \\space \\forall n \\leq n_0$ $\\Rightarrow f(n) \\in o(h(n))$ Reflexivity$f(n) \\in \\Theta (f(n))$ Symmetry$f(n) \\in \\Theta (g(n)) \\space iff \\space g(n) \\in \\Theta (f(n))$ Transpose Symmetry$f(n) \\in O(g(n)) \\space iff \\space g(n) \\in \\Omega (f(n))$ $f(n) \\in o(g(n)) \\space iff \\space g(n) \\in \\omega (f(n))$ Example1. There exists two functions $f(n)、g(n), \\space s.t. f(n) \\notin O(g(n))$ and $g(n) \\notin O(f(n))$example: $f(n) = n$ $\\space g(n) = \\begin{cases} & 1 \\text{ , if n is even} \\ & n^2 \\text{ , if n is odd } \\end{cases}$ 2. Disprove that $\\frac{1}{100} n\\log_{2}{n} \\in O(n)$ is false$\\frac{1}{100} n\\log_{2}{n} \\leq c \\cdot n \\space \\space \\forall n \\geq n_{0}$ so $\\frac{1}{100} \\log_{2}{n} \\leq c$ $\\because$ c is not constant $\\therefore$ $\\frac{1}{100} n\\log_{2}{n} \\notin O(n)$ 3. If $g(n) \\in O(f(n))$ and $g(n) \\in \\omega (h(n))$ then $f(n) \\in \\omega (h(n))$$\\because g(n) \\in O(f(n))$ $\\therefore g(n) \\leq c_{1} \\cdot f(n) \\space \\space \\forall n \\geq n_{0}$ $\\because g(n) \\in \\omega (h(n))$ $\\therefore g(n) > c_{2} \\cdot h(n) \\space \\space \\forall n \\geq n_{0}$ $c_{2} \\cdot h(n) < g(n) \\leq c_{1} \\cdot f(n)$ $\\Rightarrow f(n) > c_{3} \\cdot h(n) \\space \\space \\forall n \\geq n_{0}$ where $c_{3}$ and $n_{0}$ are positive constants $\\Rightarrow f(n) \\in \\omega (h(n))$ Recurrence RelationsSubstitution Method Guess: $T(k) \\leq c \\cdot k^4, \\space \\forall k$, for some const. $c$ Verify: Base case: $k = 1$, need $T(1) \\leq c \\cdot 1^{4} \\Rightarrow c \\geq 1$ Assume true for $k < n$, when $k = n$, $T(n) = 4T( \\frac{n}{2} ) + n \\leq 4 \\left [ c \\cdot \\left ( \\frac{n}{2}\\right )^{4} \\right ] + n = c \\cdot n^{4} + (- \\frac{3}{4} c n^{4} + n) \\leq c \\cdot n^{4}$成立若$(- \\frac{3}{4} c n^{4} + n) \\leq 0 \\Rightarrow c \\geq \\frac{4}{3}$ $\\Rightarrow T(k) \\leq c \\cdot k^{4} \\space \\forall c \\geq \\frac{4}{3}$ $\\Rightarrow T(k) = O(k^{4})$ Guess: $T(k) \\leq c \\cdot k^2, \\space \\forall k$, for some const. $c$ Verify: Base case: $k = 1$, need $T(1) \\leq c \\cdot 1^2 \\Rightarrow c \\geq 1$ Assume true for $k < n$, when $k = n$, $T(n) = 4T( \\frac{n}{2} ) + n \\leq \\left [ c \\cdot \\left ( \\frac{n}{2} \\right )^{2} \\right ] + n = cn^{2} + n \\leq c \\cdot n^2$,必不成立，所以修正猜測 Guess: $T(k) \\leq c_1 k^2 + c_2 k, \\space k$ for some const $c_1, c_2$ Verify: Base case: $k = 1, \\space T(1) \\leq c_1 \\cdot 1^{2} + c_2 \\cdot 1$$\\Rightarrow need \\space c_1 + c_2 \\geq 1$ Assume true for $k < n$when $k = n, \\space T(n) = 4T(\\frac{n}{2}) + n \\leq \\left [ c_1 \\left ( \\frac{n}{2} \\right )^{2} + c_2 \\left ( \\frac{n}{2} \\right ) \\right ] + n = c_1 n^{2} + c_2 n + \\left ( 1 + c_2 \\right ) = c_1 n^{2} + c_2 n + \\left ( 1 + c_2 \\right ) n \\leq c_1 n^{2} + c_2 n$ $\\Rightarrow 1 + c_2 \\leq 0 \\Rightarrow c_2 \\leq -1$ for some const. $c_1 = 2, c_2 = -1$ $T(n) \\leq 2n^{2} - n \\in O(n)$ Repeated Substitution$T(n) = 4T(\\frac{n}{2}) + n \\space \\space \\space$ ($k=1$) $= 4 \\left [ 4T(\\frac{n}{4})+ \\frac{n}{2} \\right ] + n \\space \\space \\space$ $= 4^{2}T(\\frac{n}{4}) + 2n + n \\space \\space \\space$ ($k=2$) $= 4^2 \\left [ 4T(\\frac{n}{8}) + \\frac{n}{4} \\right] + 2n + n$ $= 4^3 T(\\frac{n}{8}) + 4n + 2n + n \\space \\space \\space$ ($k=3$) $\\vdots$ $= 4^{k}T(\\frac{n}{2^{k}}) + (2^{k-1}n+2^{k-2}n+ \\dots +2n+n)$ $\\frac{n}{2^k} = 1 \\Rightarrow n = 2^k$ $\\Rightarrow k = log_{2}{n}$ $= n^{2} T(1) + (2^{k-1}+2^{k-2}+ \\dots +2+1)n$ $=n^{2}T(1) + \\frac{2^{k}-1}{2-1}n$ $= n^{2} \\cdot 1 +(2^{k}-1)n$ $=n^2+(n-1)n$ $= 2n^{2} - n \\in O(n^{2})$ Recursion TreeRepeated substitution的變形，節點表示每個展開代入的cost 1. $T(n) = 4T(\\frac{n}{2}) + n$, $T(1) = 1$ 每個$T(\\frac{n}{2})$再遞迴地代入 最終會迭代到$T(1) = 1$，長成高度$log_{2}n$的遞迴樹 $= \\left [n + 2n+ \\dots +2^{(log_{2}n - 1)}n \\right ] + 4^{log_{2}n}T(1)$ $= (2^{log_{2}n} -1)n + n^{2}$ $= n^{2} - n + n^{2}$ $= 2n^{2}-n \\in O(n^{2})$ 2. $T(n) = T(\\frac{2}{3}n) + T(\\frac{1}{3}n) + n$, $\\forall n \\geq 2$, $T(1)=1$ 每層cost皆為$n$，完整層(較矮那邊)高度為$log_{3}n$若整棵樹為full complete，高度為$log_{1.5}n$，實際的cost會被bounded在這之間$nlog_{3}n \\leq nlog_{2}n \\leq nlog_{1.5}n$ $\\therefore T(n) = \\Theta (nlog_{2}n)$ Master Theorem每次用recursion tree都要做等比級數、加法等運算，其實可以歸納出一套定理來快速地看出general case的遞迴時間函數 若遞迴時間函數符合以下形式: $$T(n) = aT(\\frac{n}{b}) + f(n)$$ $$a \\geq 1, b \\geq 1, f(n) \\text{ is asymptotically positive}, \\forall n \\text{ sufficiently large}$$ case 1: $f(n) = O(n^{log_{b}a} \\cdot n^{-\\varepsilon })$ where $\\varepsilon > 0$ $\\Rightarrow T(n) = \\Theta (n^{log_{b}a})$ case 2: $f(n) = \\Theta(n^{log_{b}a} \\cdot log^{k}n)$ where $k \\geq 0 \\Rightarrow T(n) = \\Theta (f(n)log_{2}n)$ case 3: $f(n) = \\Omega (n^{log_{b}a} \\cdot n^{\\varepsilon})$ where $\\varepsilon > 0$ and $af(\\frac{n}{b}) \\leq cf(n)$, for some $c < 1 \\space \\forall n \\Rightarrow T(n) = \\Theta (f(n))$ Examples1. $T(n) = 4T(\\frac{n}{2}) + n$$a=4, b=2$ $f(n) = n = O(n^{2} \\cdot n^{- \\varepsilon})$ where $0 < \\varepsilon < 1$ Apply master theorem case 1 $\\Rightarrow T(n) = \\Theta (n^{2})$ Q: 為什麼master theorem不需要初始條件? $T(1) = 1$, $T(1) = 10$, $T(1) = 100$有什麼差別?A: 初始條件只會影響$n^{2}$的係數 2. $T(n) = 3T(\\frac{n}{2}) + 8n$$a=3, b=2$ $n^{log_{b}a} = n^{log_{2}3} = n^{1.585…}$ $f(n) = 8n = O(n^{log_{2}3} \\cdot n^{-\\varepsilon})$ where $0 < \\varepsilon < 0.5$ Apply master theorem case 3 $\\Rightarrow T(n) =\\Theta (n^{log_{2}3})$ 3. $T(n) = 4T(\\frac{n}{2}) + n^{2}log^{10}n$$a=4,b=2$, $n^{log_{b}a} = n^{2}$ $f(n)=n^{2}log^{10}n = \\Theta (n^{log_{b}a} \\cdot log^{k}n)$, $k=10$ Apply master theorem case 2 $\\Rightarrow T(n) = \\Theta (n^{2}log^{11}n)$ 4. $T(n) = 4T(\\frac{n}{2}) + n^{3}$$a=4, b=2$, $n^{log_{b}a}= n^{2}$ $f(n) = n^{3}= \\Omega (n^{2} \\cdot n^{\\varepsilon})$, where $0 < \\varepsilon \\leq 1$ Apply master theorem case 3 $\\Rightarrow T(n) = \\Theta (n^{3})$ 5. $T(n) = 2T(\\sqrt{n}) + log_{2}n$, $T(2)=0$這題較特殊，要先變數變換 let $m = log_{2}n \\Rightarrow n = 2^{m}$ $T(2^{m}) = 2T(2^{\\frac{m}{2}}) + m$, $T(2)= 0$ let $S(m) = T(2^{m})$ $S(m) = 2S(\\frac{m}{2}) + m$, $S(1)=0$ $= mlog_{2}m$, by master theorem case 2 $T(n) = T(2^{m}) = S(m)$ $= mlog_{2}m$ $= log_{2}n \\cdot log_{2}log_{2}n$ Prove master theorem case 3$T(n) = aT(\\frac{n}{b}) + f(n)$ $= a \\left [aT(\\frac{n}{b^{2}}) + f(\\frac{n}{b}) \\right ] + f(n)$ $= a^{2}T(\\frac{n}{b^{2}}) + af(\\frac{n}{b})+f(n)$ $= \\dots$ $= a^{i}T(\\frac{n}{b^{i}}) + \\left [ a^{i-1}f(\\frac{n}{b^{i-1}}) + \\dots +a^{2} f(\\frac{n}{b^{2}}) + af(\\frac{n}{b}) +f(n) \\right ]$ $n=b^{i}$, $\\therefore$做$i$次, $i=log_{b}n$時迭代完畢 $= a^{log_{b}n}T(1) + \\left [ a^{i-1}f(\\frac{n}{b^{i-1}}) + \\dots +a^{2} f(\\frac{n}{b^{2}}) + af(\\frac{n}{b}) +f(n) \\right ]$ 換底公式 $= n^{log_{b}a}T(1) + \\left [ a^{i-1}f(\\frac{n}{b^{i-1}}) + \\dots +a^{2} f(\\frac{n}{b^{2}}) + af(\\frac{n}{b}) +f(n) \\right ]$ 上式主要分2項，哪邊較大會決定哪個case $\\left [ a^{i-1}f(\\frac{n}{b^{i-1}}) + \\dots +a^{2} f(\\frac{n}{b^{2}}) + af(\\frac{n}{b}) +f(n) \\right ]$裡面最大的一項為$f(n)$ $\\therefore af(\\frac{n}{b}) \\leq c \\cdot f(n)$, $c < 1$會成立，依此類推可得$a^{2}f(\\frac{n}{b^{2}}) \\leq c \\cdot af(\\frac{n}{b}) \\leq c^{2}f(n)$ $\\Rightarrow \\left [ a^{i-1}f(\\frac{n}{b^{i-1}}) + \\dots +a^{2} f(\\frac{n}{b^{2}}) + af(\\frac{n}{b}) +f(n) \\right ] \\leq \\left [ \\dots + c^{2}f(n) + cf(n) + f(n) \\right ]$ 因此$T(n)$可寫成 $T(n) = n^{log_{b}a} \\cdot T(1) + \\left [ \\dots +a^{2} f(\\frac{n}{b^{2}}) + af(\\frac{n}{b}) +f(n) \\right ]$ $\\leq n^{log_{b}a} \\cdot T(1) + \\left [ \\dots + c^{2}f(n) + cf(n) + f(n) \\right ]$ $T(n) \\leq n^{log_{b}a}T(1) + \\frac{f(n)}{1-c} \\in \\Theta (f(n))$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/02/28/introduction-to-asymptotic-notation/"},{"title":"Arduino LoRa Shield通訊實驗與NodeRED","text":"HW41.分別針對不同Spreading Factor情況下LoRa在移動下（可騎承腳踏車、搭公車、搭捷運、搭貓纜）所傳送資料的狀況做記錄（例：Packet Error Rate） 頻率設定位置: setFrequency() in the file: Sketchbook\\libraries\\RadioHead\\RH_RF95.cpp;Line 114: setFrequency(918.7); 1234567typedef enum { Bw125Cr45Sf128 = 0, ///< Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on. Default medium range Bw500Cr45Sf128, ///< Bw = 500 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on. Fast+short range Bw31_25Cr48Sf512, ///< Bw = 31.25 kHz, Cr = 4/8, Sf = 512chips/symbol, CRC on. Slow+long range Bw125Cr48Sf4096, ///< Bw = 125 kHz, Cr = 4/8, Sf = 4096chips/symbol, CRC on. Slow+long range } ModemConfigChoice; source codemyLoraServerSFtest-FieldTrailTx.ino 123456789101112131415161718192021222324252627282930313233343536#include #include RH_RF95 rf95;long counter=0;void setup() { Serial.begin(9600); delay(1000); while (!Serial) ; // Wait for serial port to be available if (!rf95.init()) Serial.println(\"init failed\"); Serial.println(); Serial.println(\"Lora init passed\"); rf95.setModemConfig(RH_RF95::Bw125Cr48Sf4096); // failed // rf95.setModemConfig(RH_RF95::Bw125Cr45Sf128); // test OK (Default medium range) // rf95.setModemConfig(RH_RF95::Bw500Cr45Sf128); // test OK (Fast + short range) // rf95.setModemConfig(RH_RF95::Bw31_25Cr48Sf512); // test OK (Slow + long range適用長距離) rf95.setTxPower(23, false);}void loop() { counter++; String numString = \"Server: \"+ String(counter, DEC)+\" \"; //加空白以去除亂碼 uint8_t data[14] = \"\"; for (int i=0; i 輸入node-red-dashboard nodes: get pm2.5 value function Publish溫溼度(DHT22)資料1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include #include #include #include \"DHT.h\"#define DHTPIN 2 // what digital pin we're connected to#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321DHT dht(DHTPIN, DHTTYPE);// set MAC addressstatic byte mac[] = { 0xF0, 0x7B, 0xCB, 0x4B, 0x7C, 0x9F };// set server and UNO IP adderss IPAddress ip(192, 168, 0, 108);IPAddress server(192, 168, 0, 105); // broker ip// Client IDconst char clientID[] = \"uno\";// topicconst char topic[] = \"home/dht22\";String msgStr = \"\";char json[25];EthernetClient ethClient; // Ethernet objectPubSubClient client(ethClient); // MQTT object basedon Ethernetvoid setup(){ Serial.begin(9600); dht.begin(); client.setServer(server, 1883); //broker and port Ethernet.begin(mac, ip); // initialize Ethernet delay(1500);}void loop(){ if (!client.connected()) { reconnect(); } client.loop(); // update MQTT client float h = dht.readHumidity() float t = dht.readTemperature();// Read temperature as Celsius (the default) // JSON format string msgStr = msgStr + \"{\\\"temp\\\":\" + (String)t + \",\\\"humid\\\":\" + (String)h + \"}\"; // turn to char array, store in json msgStr.toCharArray(json, 25); client.publish(topic, json); msgStr = \"\"; // clean delay(5000);} 加溫溼度的nodes document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/11/15/iot-course2018-HW4-HW5/"},{"title":"透過AWS IoT core儲存sensor資料至DynamoDB","text":"這是物聯網導論HW6，使用AWS IoT core與物聯網裝置經由MQTT通訊，儲存到DynamoDB，再由後端使用matplotlib繪製感測器資訊。 入門照著步驟做，先安裝pip install AWSIoTPythonSDK AWS IoT subscribe PM2.5 MQTT修改政策IOT CORE -> 安全無虞 -> 政策 -> {政策的名稱} -> 編輯政策文件 發布、訂閱程式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# basicPubSub_PM2.5.pyfrom AWSIoTPythonSDK.MQTTLib import AWSIoTMQTTClientfrom serial import Serialimport loggingimport timefrom pytz import timezone # pip install pytzfrom datetime import datetimeimport argparseimport jsonAllowedActions = ['both', 'publish', 'subscribe']# Custom MQTT message callbackdef customCallback(client, userdata, message): print(\"Received a new message: \") print(message.payload) print(\"from topic: \") print(message.topic) print(\"--------------\\n\\n\")def publish(PM25): if mode == 'both' or mode == 'publish': u = datetime.now(timezone('Asia/Taipei')) message = {} message['type'] = 'PM2.5' message['value'] = PM25 message['time'] =u.strftime('%H:%M:%S') messageJson = json.dumps(message) myAWSIoTMQTTClient.publish(topic, messageJson, 1) if mode == 'publish': print('Published topic %s: %s\\n' % (topic, messageJson))host = \"a1edmqmbezxdwv-ats.iot.us-east-1.amazonaws.com\"rootCAPath = \"./root-CA.crt\"certificatePath = \"./RPi.cert.pem\"privateKeyPath = \"./RPi.private.key\"useWebsocket = FalseclientId = \"vensen\"topic = \"RPi/PM25\"mode = \"publish\"# Port defaultsif useWebsocket: # When no port override for WebSocket, default to 443 port = 443if not useWebsocket: # When no port override for non-WebSocket, default to 8883 port = 8883# Configure logginglogger = logging.getLogger(\"AWSIoTPythonSDK.core\")logger.setLevel(logging.DEBUG)streamHandler = logging.StreamHandler()formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')streamHandler.setFormatter(formatter)logger.addHandler(streamHandler)# Init AWSIoTMQTTClientmyAWSIoTMQTTClient = Noneif useWebsocket: myAWSIoTMQTTClient = AWSIoTMQTTClient(clientId, useWebsocket=True) myAWSIoTMQTTClient.configureEndpoint(host, port) myAWSIoTMQTTClient.configureCredentials(rootCAPath)else: myAWSIoTMQTTClient = AWSIoTMQTTClient(clientId) myAWSIoTMQTTClient.configureEndpoint(host, port) myAWSIoTMQTTClient.configureCredentials(rootCAPath, privateKeyPath, certificatePath)# AWSIoTMQTTClient connection configurationmyAWSIoTMQTTClient.configureAutoReconnectBackoffTime(1, 32, 20)myAWSIoTMQTTClient.configureOfflinePublishQueueing(-1) # Infinite offline Publish queueingmyAWSIoTMQTTClient.configureDrainingFrequency(2) # Draining: 2 HzmyAWSIoTMQTTClient.configureConnectDisconnectTimeout(10) # 10 secmyAWSIoTMQTTClient.configureMQTTOperationTimeout(5) # 5 sec# Connect and subscribe to AWS IoTmyAWSIoTMQTTClient.connect()if mode == 'both' or mode == 'subscribe': myAWSIoTMQTTClient.subscribe(topic, 1, customCallback)time.sleep(2)# Publish to the same topic in a loop foreverser = Serial('/dev/ttyACM0', 9600)while True: str = ser.readline().decode('utf8')[:-2] end = str.find('\\r') PM25 = str[:end] publish(PM25) time.sleep(2) 放在與start.sh同一層路徑下 Host在start.sh內(Line 21) 123456789101112131415161718192021# stop script on errorset -e# Check to see if root CA file exists, download if notif [ ! -f ./root-CA.crt ]; then printf \"\\nDownloading AWS IoT Root CA certificate from AWS...\\n\" curl https://www.amazontrust.com/repository/AmazonRootCA1.pem > root-CA.crtfi# install AWS Device SDK for Python if not already installedif [ ! -d ./aws-iot-device-sdk-python ]; then printf \"\\nInstalling AWS SDK...\\n\" git clone https://github.com/aws/aws-iot-device-sdk-python.git pushd aws-iot-device-sdk-python python setup.py install popdfi# run pub/sub sample app using certificates downloaded in packageprintf \"\\nRunning pub/sub sample application...\\n\"python aws-iot-device-sdk-python/samples/basicPubSub/basicPubSub.py -e a3l21ss4gwlsqf-ats.iot.us-east-1.amazonaws.com -r root-CA.crt -c pi3.cert.pem -k pi3.private.key 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from AWSIoTPythonSDK.MQTTLib import AWSIoTMQTTClientfrom serial import Serialimport loggingimport timefrom pytz import timezone # pip install pytzfrom datetime import datetimeimport argparseimport jsonimport randomAllowedActions = ['both', 'publish', 'subscribe']# Custom MQTT message callbackdef customCallback(client, userdata, message): print(\"Received a new message: \") print(message.payload) print(\"from topic: \") print(message.topic) print(\"--------------\\n\\n\")def publish(PM25): if mode == 'both' or mode == 'publish': u = datetime.now(timezone('Asia/Taipei')) message = {} message['time'] = u.strftime('%H:%M:%S') message['value'] = PM25 messageJson = json.dumps(message) myAWSIoTMQTTClient.publish(topic, messageJson, 1) if mode == 'publish': print('Published topic %s: %s\\n' % (topic, messageJson))host = \"a3l21ss4gwlsqf-ats.iot.us-east-1.amazonaws.com\"rootCAPath = \"./root-CA.crt\"certificatePath = \"./RPi.cert.pem\"privateKeyPath = \"./RPi.private.key\"useWebsocket = FalseclientId = \"myRPi\"topic = \"RPi/PM25\"mode = \"publish\"# Port defaultsif useWebsocket: # When no port override for WebSocket, default to 443 port = 443if not useWebsocket: # When no port override for non-WebSocket, default to 8883 port = 8883# Configure logginglogger = logging.getLogger(\"AWSIoTPythonSDK.core\")logger.setLevel(logging.DEBUG)streamHandler = logging.StreamHandler()formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')streamHandler.setFormatter(formatter)logger.addHandler(streamHandler)# Init AWSIoTMQTTClientmyAWSIoTMQTTClient = Noneif useWebsocket: myAWSIoTMQTTClient = AWSIoTMQTTClient(clientId, useWebsocket=True) myAWSIoTMQTTClient.configureEndpoint(host, port) myAWSIoTMQTTClient.configureCredentials(rootCAPath)else: myAWSIoTMQTTClient = AWSIoTMQTTClient(clientId) myAWSIoTMQTTClient.configureEndpoint(host, port) myAWSIoTMQTTClient.configureCredentials(rootCAPath, privateKeyPath, certificatePath)# AWSIoTMQTTClient connection configurationmyAWSIoTMQTTClient.configureAutoReconnectBackoffTime(1, 32, 20)myAWSIoTMQTTClient.configureOfflinePublishQueueing(-1) # Infinite offline Publish queueingmyAWSIoTMQTTClient.configureDrainingFrequency(2) # Draining: 2 HzmyAWSIoTMQTTClient.configureConnectDisconnectTimeout(10) # 10 secmyAWSIoTMQTTClient.configureMQTTOperationTimeout(5) # 5 sec# Connect and subscribe to AWS IoTmyAWSIoTMQTTClient.connect()if mode == 'both' or mode == 'subscribe': myAWSIoTMQTTClient.subscribe(topic, 1, customCallback)time.sleep(2)# Publish to the same topic in a loop foreverser = Serial('/dev/ttyACM0', 9600)while True: str = ser.readline().decode('utf8')[:-2] end = str.find('\\r') PM25 = str[:end] publish(PM25) 在VM執行 fetch DynamoDB基本連線1234567891011121314151617import boto3from boto3.dynamodb.conditions import Keydynamodb = boto3.resource('dynamodb', region_name='us-east-1', aws_session_token='FQoGZXIvYXdzEIz//////////wEaDEmGC67DXliftdi15yLjAlNe8Meiqw9LjtH0bS2WCsEwKrtZdGVj4lEXx7YlsON2f3I6vQ4FRqen8d+hT/zUpVzDb6JVMblgslHXSUlaQWi8qovFVQtbw/AvtdlSiZlH3nENUGpev5rlVe30dl5DAiFj8HIZV47+zIcsfZXRqkL8faMpnssTCNqVRwcF4iX5U9o6vjHvMVYelW+EnUVU9/Le2bTe5QDcUsvhAOvzzZ4ZlE/SFEYfFQ4/W3cbr83NLEvU4Bqj8bqKu8L2Vmotbcong/3SFe/QgJH6KsN5Q28HDnjtnvGxFf3z2v/lGOV9e+qVWNFht5/nh6dk+JXni59hXibZa7LIZxHKAOVqs+Vk8es9JVUqm4EYH16e5fHqHLG9gSPJG64RVBa8Jth1hCjWryAlitWFdk1FTiuHdsLYIBRuPz54sdFFJFGoudEnC7/C/8eZPO+H0JseakCFZNMv9zm92cXYoJ9bS/eIu10s0Ykoi8iJ4AU=', aws_access_key_id = 'ASIA27E3PJ447BBJPJNA', aws_secret_access_key = 'taQBfl4HxZF6xyzQvflv2BT04p5sy6dMwKyeo1CE' )response = table.get_item( Key = {'time': '14:00:01'}) # 取出特定時間資料try: # print(response) item = response['Item'] message = item['message'] print(message['value'])except KeyError: print('') source code取出DB資料，存成log.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import boto3from boto3.dynamodb.conditions import Keydynamodb = boto3.resource('dynamodb', region_name='us-east-1', aws_session_token='FQoGZXIvYXdzEIz//////////wEaDEmGC67DXliftdi15yLjAlNe8Meiqw9LjtH0bS2WCsEwKrtZdGVj4lEXx7YlsON2f3I6vQ4FRqen8d+hT/zUpVzDb6JVMblgslHXSUlaQWi8qovFVQtbw/AvtdlSiZlH3nENUGpev5rlVe30dl5DAiFj8HIZV47+zIcsfZXRqkL8faMpnssTCNqVRwcF4iX5U9o6vjHvMVYelW+EnUVU9/Le2bTe5QDcUsvhAOvzzZ4ZlE/SFEYfFQ4/W3cbr83NLEvU4Bqj8bqKu8L2Vmotbcong/3SFe/QgJH6KsN5Q28HDnjtnvGxFf3z2v/lGOV9e+qVWNFht5/nh6dk+JXni59hXibZa7LIZxHKAOVqs+Vk8es9JVUqm4EYH16e5fHqHLG9gSPJG64RVBa8Jth1hCjWryAlitWFdk1FTiuHdsLYIBRuPz54sdFFJFGoudEnC7/C/8eZPO+H0JseakCFZNMv9zm92cXYoJ9bS/eIu10s0Ykoi8iJ4AU=', aws_access_key_id = 'ASIA27E3PJ447BBJPJNA', aws_secret_access_key = 'taQBfl4HxZF6xyzQvflv2BT04p5sy6dMwKyeo1CE' )## utiliy function ####################################def toTimeStamp(u): HH = str(u/3600) if u/3600 >= 10 else '0' + str(u/3600); u %= 3600; MM = str(u/60) if u/60 >= 10 else '0' + str(u/60); SS = str(u%60) if u%60 >= 10 else '0' + str(u%60); return HH + ':' + MM + ':' + SS;def toUnixTime(time): t = time.split(':'); i = 3600; sum = 0; for a in t: sum += int(a) * i; i /= 60; return sum;def getMoveAvgBy30secRange(u1): # trace back 30 sec and calculate move average res = []; u2 = u1 - 30; for i in range(u1, u2, -1): print('>>' + toTimeStamp(i)) response = table.get_item(Key={'time': toTimeStamp(i)}) try: item = response['Item'] message = item['message'] res.append(message['value']); except KeyError: print('') sum = 0; for x in res: sum += x; moveAvg = sum / len(res); return {toTimeStamp(u1) : moveAvg};#####################################################table = dynamodb.Table('PM25sensor')# settingstart_hour = '15:00:00';total = 1;list_30sec_avg = [];list_2min__avg = [];list_10min_avg = [];f = open(\"log.txt\", \"a\")# list of 30 sec move avgt1 = toUnixTime(start_hour);end = toTimeStamp(t1 - total * 3600);t2 = toUnixTime(end);print(start_hour + 'trace back to '+ end)while(t1 != t2): # list_30sec_avg.append(getMoveAvgBy30secRange(t1)); print(list_30sec_avg); t1 -= 30;print(list_30sec_avg);f.write(str(list_30sec_avg)); 產生移動平均chart123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import numpy as npimport pandas as pdimport seaborn as snsimport matplotlib.pyplot as pltfrom scipy import statsf = open('log.txt', 'r')data = f.read().split('{');data = data[1:];# print(data[1:])moveAvg_30sec = [];timeList = [];pm25List = [];for e in data: # print(e) time = e[1:9]; timeList.append(time) # print(time); s = e.split(\"': Decimal('\"); pm25 = s[1].split(\"'\")[0] pm25_float = float(pm25) pm25List.append(pm25_float) moveAvg_30sec.append({time: pm25});# visualizationdf = pd.DataFrame({'time':timeList, 'pm2.5': pm25List})# df['pm2.5'] = df['pm2.5'].astype('float64') # convert pm2.5 string to floatdf['index_col'] = df.index;print(df.head(5));fig, ax = plt.subplots(1,1)ax.set_xticklabels(df['time'], rotation=15, fontsize=18)sns.lineplot(x=\"index_col\", y=\"pm2.5\", data=df)plt.title(\"30 sec move average\")# plt.show()##### 2 min move avg# clear listtimeList = [];pm25List = [];moveAvg_2min = []for i in range(0, len(moveAvg_30sec) - len(moveAvg_30sec)%4, 4): time = moveAvg_30sec[i].keys()[0]; avg2 = (float(moveAvg_30sec[i].values()[0]) + float(moveAvg_30sec[i + 1].values()[0]) + float(moveAvg_30sec[i + 2].values()[0]) + float(moveAvg_30sec[i + 3].values()[0])) / 4; moveAvg_2min.append({time: avg2});# print (moveAvg_2min)for e in moveAvg_2min: # print(e) time = e.keys()[0]; timeList.append(time) pm25 = e.values()[0]; pm25_float = float(pm25) pm25List.append(pm25_float)# visualizationdf = pd.DataFrame({'time':timeList, 'pm2.5': pm25List})# df['pm2.5'] = df['pm2.5'].astype('float64') # convert pm2.5 string to floatdf['index_col'] = df.index;print(df.head(5));fig, ax = plt.subplots(1,1)ax.set_xticklabels(df['time'], rotation=15, fontsize=18)sns.lineplot(x=\"index_col\", y=\"pm2.5\", data=df)plt.title(\"2 min move average\")plt.show()##### 10 min move avg# clear listtimeList = [];pm25List = [];moveAvg_10min = []for i in range(0, len(moveAvg_30sec) - len(moveAvg_30sec)%20, 20): time = moveAvg_30sec[i].keys()[0]; avg10 = (float(moveAvg_30sec[i].values()[0]) + float(moveAvg_30sec[i + 1].values()[0]) + float(moveAvg_30sec[i + 2].values()[0]) + float(moveAvg_30sec[i + 3].values()[0]) + float(moveAvg_30sec[i + 4].values()[0]) + float(moveAvg_30sec[i + 5].values()[0]) + float(moveAvg_30sec[i + 6].values()[0]) + float(moveAvg_30sec[i + 7].values()[0]) + float(moveAvg_30sec[i + 8].values()[0]) + float(moveAvg_30sec[i + 9].values()[0]) + float(moveAvg_30sec[i + 10].values()[0]) + float(moveAvg_30sec[i + 11].values()[0]) + float(moveAvg_30sec[i + 12].values()[0]) + float(moveAvg_30sec[i + 13].values()[0]) + float(moveAvg_30sec[i + 14].values()[0]) + float(moveAvg_30sec[i + 15].values()[0]) + float(moveAvg_30sec[i + 16].values()[0]) + float(moveAvg_30sec[i + 17].values()[0]) + float(moveAvg_30sec[i + 18].values()[0]) + float(moveAvg_30sec[i + 19].values()[0])) / 20; moveAvg_10min.append({time: avg10});for e in moveAvg_10min: # print(e) time = e.keys()[0]; timeList.append(time) pm25 = e.values()[0]; pm25_float = float(pm25) pm25List.append(pm25_float)# visualizationdf = pd.DataFrame({'time':timeList, 'pm2.5': pm25List})# df['pm2.5'] = df['pm2.5'].astype('float64') # convert pm2.5 string to floatdf['index_col'] = df.index;# print(df.head(5));fig, ax = plt.subplots(1,1)ax.set_xticklabels(df['time'], rotation=15, fontsize=18)sns.lineplot(x=\"index_col\", y=\"pm2.5\", data=df)plt.title(\"10 min move average\")plt.show() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/11/26/iot-course2018-HW6/"},{"title":"CVSD 2018 Fall Notebook","text":"Verilog基本語法Operators Bitwise Operators(每個bit都會做): ~(invert)加在兩變數中間變數之前 &,|,^(XOR),~^(XNOR) ex:~m,m&n Unary Operators (加在變數之前，對自己的每個bit做運算，縮至一個bit)&,~&,|,~|,^,~^ ex: &m Arithmetic Operators: +,-(放在兩個數字中間當兩數相減、放在一個數字前面代表對他取二補數),(無號數的乘法),/,%(取餘數，這個指令不可合成) ex: m+n Logic Operators: !(not),&&,|| ex:!m Equality Operators(比較數值): == (數值是否相等?), != (does not equal?) ex: m==n Identity Operators(不可合成，只用在testbench): === (是否等價?多考慮X、Z的狀態), !== (是否不相同) ex: m===n Relational Operators: ,= Logical Shift Operators: ex: m","link":"/2018/11/12/cvsd-note/"},{"title":"使用STM32安裝RTOS與除錯 - 下載FreeRTOS與SEGGER SystemView","text":"本篇使用Eclipse IDE(openSTM32 System Workbench)在STMF411RE板子上引入FreeRTOS函式庫以及設置SEGGER SystemView在Debugger視覺化執行中的Tasks FreeRTOS 到FreeRTOS下載kernel Create Config and Third-Party FreeRTOS可以砍Source>protable中其他部需要的，如下圖 不要勾選Exclude resource from build，然後按apply再按OK Link RTOS source file一樣的方法加入ARM_CM4F FreeRTOS config.h 在D:\\Workspace\\RTOS_Workspace\\STM32_HelloWorld\\建立Config資料夾 到以下路徑D:\\Workspace\\Software&Toolchain\\FreeRTOSv10.2.1\\FreeRTOS\\Demo\\CORTEX_M4F_STM32F407ZG-SK複製FreeRTOSConfig.h 放進D:\\Workspace\\RTOS_Workspace\\STM32_HelloWorld\\Config refresh之後同樣需要取消選取 SEGGER SystemView 視覺化RTOS的時序工具，由德國SEGGER公司開發，有以下功能 列出RTOS執行中的Task，以及他們花費的CPU時間 顯示ISR進入與離開的時間點 分析Task的行為(Blocking、Unblocking、Notifying、Yielding) 分析CPU閒置時間 (我們可以在這些時間讓MCU進入睡眠狀態減少功耗) 可使用Continuous recording或single-shot recording Real time recording 架構圖RTT: Real time transfer 環境設定Step 1: Including SEGGER SystemView in the applicationStep 1-1在Thirt-Party下建立一個SEGGER資料夾 Step 1-2 Step 1-3Include path加入Config 同樣方法加入OS、SEGGER，按Apply > OK Step 2: Patching FreeRTOS files Step 3: FreeRTOSConfig.h Settings1#include \"SEGGER_SYSVIEW_FreeRTOS.h\" 這個標頭檔定義了 trace macros 來產生 SYSTEMVIEW events 12#define INCLUDE_xTaskGetIdleTaskHandle 1#define INCLUDE_pxTaskGetStackStart 1 Step 4: MCU and Project specific settingsStep 4-1在SEGGER_SYSVIEW_Conf.h定義你用的處理器類型 Step 4-2 在SEGGER_SYSVIEW_Conf.h設置 SystemView buffer size (SEGGER_SYSVIEW_RTT_BUFFER_SIZE) Step 4-3在SEGGER_SYSVIEW_Conf_FreeRTOS.c設置 application specific 資訊(SRAM base address)，參閱reference manual 連結 Step 5: Enable the ARM Cortex Mx Cycle Counter在main.c中DWT->CTRL的第一個bit設為1，這樣就能記錄CPU的timestamp Step 6: Start the recoding of events如下呼叫SEGGER APIs來開始FreeRTOS的行為 12SEGGER_SYSVIEW_Conf();SEGGER_SYSVIEW_Start(); Step 7: Complie, Flash and Debug 編譯並燒錄 FreeRTOS + SystemView application openSTM32 System Workbench的IDE中進入debugging mode 按一下run幾秒後，再按pause Step 8: Collect the recorded data (RTT buffer)不管continuous recording 或single-shot recording(這裡使用single-shot recording)都要設置RTT buffer 取得SystemView RTT buffer address與number of bytes，分別是Normally_SEGGER_RTT.aUp[1].pBuffer與_SEGGER_RTT.aUp[1].WrOff 這裡的RTT buffer的start address是 0x200136f0 number of bytes 是 8189 接著將memory dump存成檔案 Save the file with .SVdat extension 到SystemView載入此檔案開始分析 J-Link如果要continus recording，下載J-Link software package 就能將原本Nucleo板子上的ST-LINK改成J-LINK，分析完CPU行為之後，再改回ST-LINK就能繼需開發囉~ 非常方便 Download: https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/11/24/install-freeRTOS-and-SEGGER-SystemView/"},{"title":"Leetcode - Balanced Binary Tree","text":"110. Balanced Binary TreeGiven a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1: 12345678Given the following tree [3,9,20,null,null,15,7]: 3 / \\ 9 20 / \\ 15 7Return true. Solution平衡二元樹定義：左右子樹高度差小於等於1且左右子樹皆為平衡二元樹 Code1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isBalanced(TreeNode* root) { if(!root) return true; return abs(hight(root->left) - hight(root->right)) left) && isBalanced(root->right); } int hight(TreeNode* root) { if(!root) return 0; return max(hight(root->left), hight(root->right)) + 1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/11/17/leetcode-Balanced-Binary-Tree/"},{"title":"JavaScript 筆記 - 依序執行function","text":"之前做C3.js圖表平移效果，網頁載入後平移9次，於是寫了9次callback 123456789setTimeout(function(){console.log('shift ', 1)}, 1000);setTimeout(function(){console.log('shift ', 2)}, 2000);setTimeout(function(){console.log('shift ', 3)}, 3000);setTimeout(function(){console.log('shift ', 4)}, 4000);setTimeout(function(){console.log('shift ', 5)}, 5000);setTimeout(function(){console.log('shift ', 6)}, 6000);setTimeout(function(){console.log('shift ', 7)}, 7000);setTimeout(function(){console.log('shift ', 8)}, 8000);setTimeout(function(){console.log('shift ', 9)}, 9000); (｀・ω・´)…….. 呵 宣告function回傳promise 12345678const shiftPromise = (round) => { return new Promise((resolve, reject) => { setTimeout(() => { console.log(`shift ${round}`); resolve(round); }, 1000); });} 解法1: resolve()1234567891011Promise.resolve() .then(() => shiftPromise(1)) .then(() => shiftPromise(2)) .then(() => shiftPromise(3)) .then(() => shiftPromise(4)) .then(() => shiftPromise(5)) .then(() => shiftPromise(5)) .then(() => shiftPromise(6)) .then(() => shiftPromise(7)) .then(() => shiftPromise(8)) .then(() => shiftPromise(9)) 將return的promise一直串下去，但這方法還是很醜，要寫9次 解法2: reduce()展開跟解法1一樣 arr.reduce(callback[accumlator, currentValue, currentIndex, array], initialValue) 123456789[1, 2, 3, 4, 5, 6, 7, 8, 9].reduce((p, current) => { return p.then(() => shiftPromise(current))},Promise.resolve()) // 簡寫 去掉return、curly braces[1, 2, 3, 4, 5, 6, 7, 8, 9].reduce( (p, current) => p.then(() => shiftPromise(current)), Promise.resolve()) 解法3: async/await這是最簡潔的寫法! 這種情況可以用IIFE去執行 12345(async(dataArray) => { for(let i = 0; i < dataArray.length; i++) { await shiftPromise(dataArray[i]); }})([1, 2, 3, 4, 5, 6, 7, 8, 9]); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/02/03/js-promise-execute-sequentially/"},{"title":"Leetcode - Maximum Level Sum of a Binary Tree","text":"1161. Maximum Level Sum of a Binary TreeGiven the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on. Return the smallest level X such that the sum of all the values of nodes at level X is maximal. Example 1: 1234567Input: [1,7,0,7,-8,null,null]Output: 2Explanation: Level 1 sum = 1.Level 2 sum = 7 + 0 = 7.Level 3 sum = 7 + -8 = -1.So we return the level with the maximum sum which is level 2. Solution 用hash以DFS紀錄每層的和，key為層數，value為該層之和 $O(h)$找level sum最大值 $O(h)$找擁有level sum最大值且level最小的 （可能有多個level之和都是max） Code123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: unordered_map um; // depth, sum int maxLevelSum(TreeNode* root) { dfs(root, 0); // O(n) // get the maximum sum int max = INT_MIN; for(auto [key, val] : um) { // O(n) if(val > max) max = val; } // get the smallest level which has maximum sum int min_idx = INT_MAX; for(auto [key, val] : um) { // O(n) if(val == max && key < min_idx) min_idx = key; } return min_idx + 1; // level start from 1 } void dfs(TreeNode* root, int d) { if(!root) return; um[d] += root->val; dfs(root->left, d + 1); dfs(root->right, d + 1); }}; Complexity$O(n)$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/12/14/leetcode-Maximum-Level-Sum-of-a-Binary-Tree/"},{"title":"Leetcode - Convert Sorted Array to Binary Search Tree","text":"108. Convert Sorted Array to Binary Search TreeGiven an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 Solution因為nums是排序好 要balanced就拿中間當root會切分出左右子陣列遞迴處理成左右子樹 Code12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* sortedArrayToBST(vector& nums) { return bfs(nums, 0, nums.size() - 1); } TreeNode* bfs(vector& nums, int left, int right) { if(left > right) return NULL; int mid = left + (right - left) / 2; TreeNode* pNode = new TreeNode(nums[mid]); pNode->left = bfs(nums, left, mid - 1); pNode->right = bfs(nums, mid + 1, right); return pNode; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/12/20/leetcode-Convert-Sorted-Array-to-Binary-Search-Tree/"},{"title":"Leetcode - Maximum Product of Splitted Binary Tree","text":"1339. Maximum Product of Splitted Binary TreeGiven a binary tree root. Split the binary tree into two subtrees by removing 1 edge such that the product of the sums of the subtrees are maximized. Since the answer may be too large, return it modulo 10^9 + 7. Example 1: 123Input: root = [1,2,3,4,5,6]Output: 110Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10) Solution先求出整棵樹的和$sumT$postorder traverse過程,計算切分後的左右乘積,更新最大值 有2種切法case 1: $prodect = sumL * (sumT - sumL)$case 2: $prodect = (sumT - sumR) * sumR$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: long ans; long sumT; // summation of whole tree int maxProduct(TreeNode* root) { // init const int modv = 1e9 + 7; ans = 0; sumT = sum(root); // update maximum postorder(root); return ans % modv; } long sum(TreeNode* root) { // postorder if(!root) return 0; return root->val + sum(root->left) + sum(root->right); } int postorder(TreeNode* root) { if(!root) return 0; long sumL = postorder(root->left); long sumR = postorder(root->right); // ans = max({ans, sumL * (sumT - sumL), // case 1 (sumT - sumR) * sumR}); // case 2 return root->val + sumL + sumR; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/01/09/leetcode-Maximum-Product-of-Splitted-Binary-Tree/"},{"title":"Leetcode - Check If N and Its Double Exist","text":"1346. Check If N and Its Double ExistGiven an array arr of integers, check if there exists two integers $N$ and $M$ such that $N$ is the double of $M$ ( i.e. $N = 2\\times M$). More formally check if there exists two indices i and j such that : i != j 0","link":"/2019/10/21/leetcode-Check-If-N-and-Its-Double-Exist/"},{"title":"Leetcode - Merge Two Sorted Lists","text":"21. Merge Two Sorted ListsMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1->2->4, 1->3->4Output: 1->1->2->3->4->4 Method 1 - Recursive12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1 == NULL && l2 == NULL) return NULL; if(l1 == NULL) return l2; if(l2 == NULL) return l1; ListNode* l3 = NULL; if(l1->val val) { l3 = new ListNode(l1->val); l3->next = mergeTwoLists(l1->next, l2); } else { l3 = new ListNode(l2->val); l3->next = mergeTwoLists(l1, l2->next); } return l3; }}; Method 2 - Iterative雖然題目說要產生new list，但是這個方法還是可以過 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode l3(0); ListNode* ptr3 = &l3; while(l1 && l2) { if(l1->val < l2->val) { ptr3->next = l1; l1 = l1->next; } else { ptr3->next = l2; l2 = l2->next; } ptr3 = ptr3->next; } ptr3->next = (l1) ? l1 : l2; return l3.next; }}; l3是一個dummy node，好處是執行完這個函式的stack就會自動釋放記憶體。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/09/24/leetcode-Merge-Two-Sorted-Lists/"},{"title":"Leetcode - Serialize and Deserialize Binary Tree","text":"297. Serialize and Deserialize Binary TreeSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Solution12345 1 / \\2 3 / \\ 4 5 用preorder(DLR)轉成序列會是”12XX34XX5XX”, “X”代表NULL 這題沒有規定轉成的string要長怎樣，只要能decode回原樹即可 二元樹狀結構preorder的序列，如果沒有紀錄NULL就必須搭配inorder才能確定唯一的二元樹 最簡潔是用string stream，轉成序列時用空白分隔nodes，方便再decode的時候讀入node Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Codec {public: // Encodes a tree to a single string. string serialize(TreeNode* root) { ostringstream out; preorder(root, out); return out.str(); } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { istringstream in(data); return decode(in); }private: void preorder(TreeNode* root, ostringstream& out) { if(!root) { out < node; if(node == \"X\") return NULL; TreeNode* root = new TreeNode(stoi(node)); root->left = decode(in); root->right = decode(in); return root; }};// Your Codec object will be instantiated and called as such:// Codec codec;// codec.deserialize(codec.serialize(root)); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/01/17/leetcode-Serialize-and-Deserialize-Binary-Tree/"},{"title":"Leetcode - Same Tree","text":"基本的tree結構操作另外還有101. Symmetric Tree, 226. Invert Binary Tree, 450. Delete Node in a BST, 872. Leaf-Similar Trees, etc. 100. Same TreeGiven two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: 123456Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]Output: true Example 2: 123456Input: 1 1 / \\ 2 2 [1,2], [1,null,2]Output: false Example 3: 1234567Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]Output: false Code1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p == NULL && q == NULL) return true; else if(p != NULL && q != NULL) { return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right); } else return false; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/12/25/leetcode-Same-Tree/"},{"title":"LeetCode - Delete Node in a Linked List","text":"據說是微軟面試題…算是腦筋急轉吧，事實上沒有真的delete node而是直接skip該node。 237. Delete Node in a Linked ListWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list – head = [4,5,1,9], which looks like following: Example 1: 123Input: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function. Example 2: 123Input: head = [4,5,1,9], node = 1Output: [4,5,9]Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function. Note: The linked list will have at least two elements. All of the nodes’ values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. Code123456789101112131415/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: void deleteNode(ListNode* node) { node->val = node->next->val; node->next = node->next->next; }}; Time complexity$O(1)$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/12/13/leetcode-delete-node-in-a-linked-list/"},{"title":"Leetcode - Diameter of Binary Tree","text":"Tree資料結構的操作與postorder traversal 543. Diameter of Binary TreeGiven a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example: 123456Given a binary tree 1 / \\ 2 3 / \\ 4 5 Solutionpostorder traversal會訪問所有tree node，所以一定會經過左右子樹高度最長的root(如下圖node 2)，構成題目定義的直徑，在traversal過程一定會經過此點，若有更長的直徑則更新diameter的值 Code123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int diameterOfBinaryTree(TreeNode* root) { int diameter = 0; postorder(root, diameter); return diameter; } int postorder(TreeNode* root, int& diameter) { // LRD: postorder traversal if(!root) return 0; int lh = postorder(root->left, diameter); int rh = postorder(root->right, diameter); diameter = max(diameter, lh + rh); // update max return max(lh, rh) + 1; }}; Time complexity$O(n)$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/11/24/leetcode-diameter-of-binary-tree/"},{"title":"LeetCode - Letter Combinations of a Phone Number","text":"17. Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: 123Input: \"23\"Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].Note: Although the above answer is in lexicographical order, your answer could be in any order you want. Solution1DFS(text, i) $text$ := 目前字串$digits_i$ := 數字鍵，對應字母從key取得，例如”2”對應”abc” Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: vector ans; int n; string _digits; vector key; void dfs(string text, int i) { if(i == n) { // leaf ans.push_back(text); return; } string letters = key[_digits[i] - '0']; for(char c : letters) { text.push_back(c); dfs(text, i + 1); text.pop_back(); } } vector letterCombinations(string digits) { n = digits.size(); _digits = digits; if(n == 0) return ans; key.push_back(\"\"); key.push_back(\"\"); key.push_back(\"abc\"); // 2 key.push_back(\"def\"); // 3 key.push_back(\"ghi\"); // 4 key.push_back(\"jkl\"); // 5 key.push_back(\"mno\"); // 6 key.push_back(\"pqrs\"); // 7 key.push_back(\"tuv\"); // 8 key.push_back(\"wxyz\"); // 9 dfs(\"\", 0); return ans; }}; Time complexity就是整個tree的node數令$digits$長度$n$複雜度約為公比$3$等比級數前$n$項的和$\\therefore O(3^n)$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/12/16/leetcode-letter-combinations-of-a-phone-number/"},{"title":"Leetcode - Binary Tree Level Order Traversal","text":"Tree traversal基本題 102. Binary Tree Level Order TraversalGiven a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] Solution就BFS Code123456789101112131415161718192021222324252627282930313233class Solution {public: vector levelOrder(TreeNode* root) { vector ans; bfs(ans, root, 0); return ans; } private: // unordered_map um; void bfs(vector& ans, TreeNode* root, int depth) { if(!root) return; // record // 檢查是否超過存取範圍 if(ans.size() > depth) { // 沒超過 ans[depth].push_back(root->val); } else { // 超過範圍，新增一層 vector vec{root->val}; ans.push_back(vec); } bfs(ans, root->left, depth + 1); bfs(ans, root->right, depth + 1); }}; 再補一題N-ary的版本 429. N-ary Tree Level Order Traversal 12Input: root = [1,null,3,2,4,null,5,6]Output: [[1],[3,2,4],[5,6]] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*// Definition for a Node.class Node {public: int val; vector children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector _children) { val = _val; children = _children; }};*/class Solution {public: vector levelOrder(Node* root) { vector ans; bfs(ans, root, 0); return ans; } void bfs(vector& ans, Node* root, int depth) { if(!root) return; if(ans.size() > depth) { ans[depth].push_back(root->val); } else { vector vec{root->val}; ans.push_back(vec); } if(root->children.size() != 0) { for(auto child : root->children) { bfs(ans, child, depth + 1); } } }}; Time complexity$O(n)$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/10/17/leetcode-binary-tree-level-order-traversal/"},{"title":"LeetCode - Generate Parentheses","text":"排列組合問題常用的DFS解法加一個”(“，未來就要用一個”)”來構成一組合法括號紀錄可用的”(“與”)”數量試著畫出這棵二元樹就清楚了 LeetCode - 22. Generate ParenthesesGiven $n$ pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given $n = 3$, a solution set is: 1234567[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"] SolutionDFS(s, open, close) $s$: current string$open$: number of left parentheses can be appended to current string$close$: number of right parentheses can be appended to current stringAn answer is generated when $open = close = 0$ (base case) Code1234567891011121314151617181920class Solution {public: vector generateParenthesis(int n) { dfs(\"\", n, 0); return ans; } vector ans; void dfs(string s, int open, int close) { if(open == 0 && close == 0) { ans.push_back(s); } if(open) dfs(s + \"(\", open - 1, close + 1); if(close) dfs(s + \")\", open , close - 1); }}; Time complexityHuh… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/10/16/leetcode-generate-parentheses/"},{"title":"LeetCode - Longest Palindromic Substring","text":"5. Longest Palindromic Substring求最長迴文子字串 Example 1: 12Input: \"babad\"Output: \"bab\" Example 2: 12Input: \"cbbd\"Output: \"bb\" Solution初始設最大值max_len為0i從0到n以下兩個case的迴文子字串長度取較大的值 奇數長度迴文子字串以s[i]為中心擴散 (e.g. “aba”, i = 1) 偶數長度迴文子字串以s[i]、s[i + 1]擴散 (e.g. “abba”, i = 1) 若比max_len則更新，並用start紀錄該迴文子字串起始點 Code123456789101112131415161718192021222324252627282930313233class Solution {public: string longestPalindrome(string s) { auto getLength = [&](int i, int j) { // return the length of longest palindromic substring while(i>= 0 && j < s.size() && s[i] == s[j]) { i--; j++; } return j - i - 1; }; int max_len = 0; int start = 0; for(int i = 0; i < s.size(); ++i) { // O(n) int cur = max(getLength(i, i), getLength(i, i + 1)); // O(n) if(cur > max_len) { // update max_len = cur; start = i - (max_len - 1) / 2; } } return s.substr(start, max_len); } }; Time complexity$O(n^2)$ Note用C++11 Lambda來簡化寫法，參考C++11 Lambda Expression 語法教學與範例 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/11/23/leetcode-longest-palindromic-substring/"},{"title":"LeetCode - Minimum Insertion Steps to Make a String Palindrome","text":"1312. Minimum Insertion Steps to Make a String PalindromeGiven a string s. In one step you can insert any character at any index of the string. Return the minimum number of steps to make s palindrome. A Palindrome String is one that reads the same backward as well as forward. Solution$dp[i][j]$ := min insertions to make s[i ~ j] a palindrome 分兩種case討論，字串$S = s_{i} s_{i+1} … s_{j}$檢查$s_i$與$s_j$也就是字串頭尾字元是否一樣 是，$dp[i][j]$的解就是$dp[i + 1][j - 1]$ 否，可以選擇在頭尾插入，方法數+1，取較小的 頭插入$s_{j}$，所以插入方法數為$dp[i][j - 1] + 1$ 尾插入$s_{i}$，所以插入方法數為$dp[i + 1][j] + 1$ 因為求解長度$k$的子字串，會要知道$k-1$、$k-2$長度的子字串方法數，外迴圈從長度$l=2$的子字串開始到長度$n$，最後$dp[0][n-1]$就是答案 Code123456789101112131415161718class Solution {public: int minInsertions(string s) { const int n = s.length(); vector dp(n, vector(n)); for(int l = 2; l { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/12/01/leetcode-minimum-insertion-steps-to-make-a-string-palindrome/"},{"title":"Leetcode - Reverse Linked List","text":"有兩種方法，iteration & recursion 206. Reverse Linked List1234Example:Input: 1->2->3->4->5->NULLOutput: 5->4->3->2->1->NULL Method 1 - recursion12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { if(head == NULL || head->next == NULL) return head; ListNode* ptr = head->next; head->next = NULL; ListNode* head2 = reverseList(ptr); ptr->next = head; return head2; }}; Method 2 - iteration12345678910111213141516171819202122class Solution {public: ListNode* reverseList(ListNode* head) { ListNode* head2 = NULL; for(ListNode* itr = head; itr != NULL; itr = itr->next) // O(n) insert(head2, itr->val); // add to head return head2; } void insert(ListNode*& head, int val) { // add to head ListNode* newNode = new ListNode(val); newNode->next = head; head = newNode; }}; Time complexity$O(n)$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/09/23/leetcode-reverse-linked-list/"},{"title":"Matlab常用函數 - 作圖與微分積分求解","text":"Symbolic functionezplot可以直接輸入字串 12fx = '10*sin(x)';h = ezplot(fx); 與ezplot不同，fplot的第一個參數是匿名函式，第二個參數可指定x軸範圍 12fy = @(y) 10*sin(y) + tan(y/2)/10;h = fplot(fy, [-15 5]); Implicit function1234fts = @(r,t,s) 2.^(t.*s) + r.*s - t.*s.^(1/3);h = fimplicit3(fts);rotate3d on, axis imageset(h, 'linestyle', 'none') Polar function123cardioid = @(t) 2*(1-cos(t));h = ezpolar(cardioid);set(h, 'linew', 2, 'color', 'r') Function limits使用limit求$\\lim_{x\\to 5} \\frac{x^2 - 25}{x^2+x-30}$，並作圖。 1syms x 用syms宣告symbolic variables，可視為一個placeholder，這樣就不用宣告特定x的vector，Matlab會幫我們解析表達式。 若宣告為vector形式，x = [-10:.01:10]稱為numeric variables 12345678910fx = (x^2 - 25) / (x^2+x-30);fplot(fx, [-10 10], 'linew', 2)a = 5;lim5 = limit(fx, x, a);hold onplot([1 1]*a, get(gca, 'ylim'), 'r--')plot(get(gca, 'xlim'), [1 1]*lim5, 'r--')title('$$f(x) = \\frac{x^2 - 25}{x^2+x-30}$$','interpreter','latex') 計算$x\\to -6$的左極限與右極限 12limit(fx, x, -6, 'left')limit(fx, x, -6, 'right') Function Derivatives 求$f(x) = sin(x)$導數並作圖 回傳$f(x)$與$\\frac{df(x)}{dx}$在$x=\\pi / 3$的symbolic expression 12345678910syms x % symbolic variablesf = sin(x);df = diff(f);subplot(211)fplot(f)hold onfplot(df)legend(['f(x) = ' char(f)], ['df = ' char(df)]) subs: Symbolic substitution 123a = pi / 3;subs(f, a) % 3^(1/2)/2subs(df, a) % 1/2 一樣的函數，在numeric運算，注意會有取樣間隔與導數的vector長度的問題 123456789Ts = .001;t = -5:Ts:5;y = sin(t);dy = diff(y) * 1/Ts; % 這裡是discrete derivatives，所以輸出的vector長度會比原本少1subplot(212)plot(t, y)hold onplot(t(1:end-1), dy) % t少取一個才會跟dy長度一樣legend({'y(t)', 'dy'}) 接下來 fplot畫出以下函數與其導函數的圖形 pretty在console印出數學式 縱軸範圍-300到300 $$f(x) = \\frac{e^{sin(x)^x}}{3^x cos(x)}$$ 12345syms xf = exp(sin(x))^x/(3^x * cos(x));df = diff(f);pretty(f) 可用來對照有沒有打錯函數 1pretty(df) 嗯…雖然還是醜醜的，但是相對好閱讀 123456figure(8), clffplot(f, 'linew', 2)hold onfplot(df, 'linew', 2)legend({'f(x)', 'df'})set(gca, 'ylim', [-300 300]) Function integration求$f(x) = x^4$ 不定積分並作圖 12345678syms xf = x^4;intf = int(f);figure(9), clf, hold onfplot(f, [-2 2])fplot(intf, [-2 2])legend(['f(x) = ' char(f)], ['\\int f dx = ' char(intf) '+C']) 分別對x與y做$f(x,y) = x^2 + y^3$分部積分 用subs代入$(x, y) = (4, 3)$求值 12345678syms x yfxy = x^2 + y^3;int(fxy, x) % x^3/3 + x*y^3int(fxy, y) % x^2*y + y^4/4subs(int(fxy, x), [x y], [4 3]) % 388/3 對以下函數不定積分 $$f(x)=\\frac{sec(x) log(tan(x)sin(x) + sin(x)) }{e^x}$$ 12345syms x f = sec(x) * log(tan(x)*sin(x) + sin(x)) / exp(x);figure(10), clf, hold onfplot(f, [-20 10], 'linew', 2) 若直接用int求 1intf = int(f); 將會回傳int((exp(-x)log(sin(x) + sin(x)tan(x)))/cos(x),x)，代表這個函數沒有一個symbolic的解 較好的方式是用numerical方法去近似，也就是代入一個vector的每個值到匿名函數去求解 integral - Numerically evaluate integral 匿名函數要用element-wise運算 積分後real取實部，用plot畫出 12345678910111213141516171819202122232425syms x f = sec(x) * log(tan(x)*sin(x) + sin(x)) / exp(x);figure(10), clf, hold onfplot(f, [-20 10], 'linew', 2)intf = int(f);% calculate numericallyintvec = linspace(-20, 10, 100);intf2 = zeros(size(intvec)); % initializefuncf = @(x) sec(x) .* log(tan(x).*sin(x) + sin(x)) ./ exp(x);for i = 1:length(intvec) intf2(i) = integral(funcf, intvec(1), intvec(i)); % Q = INTEGRAL(FUN,A,B) approximates the integral of function FUN from A % to B using global adaptive quadrature and default error tolerances.endplot(intvec, real(intf2), 'linew', 2)legend(['f(x)'], ['\\int f dx']) Solving Differential Equations常見電路分析，電容與電感在時域是微分項，也會有初始電壓等情況(initial condition)，透過matlab可以驗證電路行為。 求解以下微分方程式 General solution Particular solution $y(0) = {2,1, 0.75,0.5 }$ 使用syms, diff, dsolve, meshgrid, ezplot, quiver $$\\frac{dy}{dt} = e^{-t} - 2y$$ 123syms y(t)eq = diff(y) == exp(-t) - 2*y; dsolve基本用法 123dsolve(eq) % exp(-t) + C1*exp(-2*t)dsolve(eq, y(0) == 2) % exp(-t) + exp(-2*t) 畫出背景的gradient vector meshgrid: $2 \\leq x \\leq 3, -1 \\leq y \\leq 2$分別為30點與32點的網格 quiver: 參數為x、y座標、正規化向量、箭頭大小 12345678% slope curves[t1, y1] = meshgrid(linspace(-2, 3, 30), linspace(-1, 2, 32));f = exp(-t1) - 2*y1; L = sqrt(1^2 + f.^2); % plotfigure(11), clf, hold onh = quiver(t1, y1, 1./L, f./L, .5); h是個placeholder，用來設置樣式，例如將箭頭顏色設成灰色 1set(h,'color', [.8 .8 .8]) 用ezplot畫出不同initial value的解的曲線 1234567891011% initial valuesinitvals = [2 1 .75 .5];% draw solution curves for the initial valuesh1 = zeros(size(initvals));for i = 1:length(initvals) h1(i) = ezplot(dsolve(eq, y(0) == initvals(i)), [min(t1(:)) max(t1(:))]);end% set axis limitaxis([min(t1(:)) max(t1(:)) min(y1(:)) max(y1(:))]) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/01/09/matlab-plot-functions/"},{"title":"LeetCode - Maximum Depth of Binary Tree","text":"104. Maximum Depth of Binary TreeSolution Code1234567891011121314151617class Solution {public: int maxDepth(TreeNode* root) { int d = 1, max_d = 0; preorder(root, d, max_d); return max_d; } void preorder(TreeNode* root, int d, int& max_d) { if(!root) return; max_d = max(d, max_d); if(root->left) preorder(root->left, d+1, max_d); if(root->right) preorder(root->right, d+1, max_d); return; }}; Time ComplexityDFS: $O(V+E)$, $E = V - 1$ $\\Rightarrow O(V)$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/11/01/leetcode-maximum-depth-of-binary-tree/"},{"title":"Memory Illustrator","text":"Image to teach user dump log file https://tinyurl.com/y4y7lcjl Input dump.txt 1234567890x200004CC 00 00 00 00 D9 AB 17 3F - 15 04 C2 BD 15 EF 43 3E .......?......C>0x200004DC 00 00 80 3F 09 B8 D5 3E - F3 04 B5 3E 72 AD A0 3F ...?...>...>r..?0x200004EC D7 B3 5D 3F 5E 83 EC 3E - B2 E4 A8 3F 8D 65 97 3F ..]?^..>...?.e.?0x200004FC 00 00 00 3F 8D 65 97 3F - B2 E4 A8 3F 5E 83 EC 3E ...?.e.?...?^..>0x2000050C D7 B3 5D 3F 72 AD A0 3F - F3 04 B5 3E 09 B8 D5 3E ..]?r..?...>...>0x2000051C 00 00 80 3F 15 EF 43 3E - 15 04 C2 BD D9 AB 17 3F ...?..C>.......?0x2000052C 00 00 00 80 D9 AB 17 BF - 15 04 C2 3D 15 EF 43 BE ...........=..C.0x2000053C 00 00 80 BF 09 B8 D5 BE - F3 04 B5 BE 72 AD A0 BF ............r...0x2000054C D7 B3 5D BF 5E 83 EC BE - B2 E4 A8 BF 8D 65 97 BF ..].^........e.. plot outputAry with C3.js https://c3js.org/samples/simple_xy.html What is MemoryIllustrator? This is a tool to plot float array from a memory segment of ARM STM32 Series board. Just for fun :P Useless document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/01/08/memory-illustrator/"},{"title":"ModelSim 專案建立&模擬 步驟","text":"Step 1: 用文字編輯器撰寫程式碼隨意路徑隨意(不要有中文) Step 2: 開啟ModelSim，File>New>Project建立Project Project name、Library name隨意命名 按OK後，點選Add Existing File 按Browse選擇剛剛編輯檔案的路徑，按OK完成專案建立 Step 3: 編譯Verilog code 編譯成功或失敗會在Transcript視窗顯示 程式庫(Library)已有對應的檔案 Step 4: 模擬對t(module)按右鍵>Simulate document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2017/09/27/modelSim-create-project-note/"},{"title":"Leetcode - Sliding Window Maximum","text":"239. Sliding Window MaximumMethod 1 - Brute force這題測資很弱，暴力解也給過= = 使用std::max_element(nums.begin() + i, nums.begin() + j)，回傳i到j(不含)的最大值iterator 1234567891011121314151617class Solution {public: vector maxSlidingWindow(vector& nums, int k) { const int n = nums.size(); vector ans; // empty case if(n == 0) return ans; for(int i = 0, j = k - 1; j < n; ++i, ++j) { auto max = max_element(nums.begin() + i, nums.begin() + j + 1); ans.push_back(*max); } return ans; }}; ComplexityTime: $O(nk)$Space: $O(1)$ Method 2 - BST12345678910111213141516171819202122class Solution {public: vector maxSlidingWindow(vector& nums, int k) { vector ans; if (nums.size() == 0) return ans; // Pick first k elements and create a Self-Balancing Binary Search Tree (BST) of size k. multiset window(nums.begin(), nums.begin() + k); for(int i = 0, j = k ; j < nums.size(); ++i, ++j) { ans.push_back(*window.rbegin()); // get maximum of BST window.insert(nums[j]); // add nums[j] window.erase(window.equal_range(nums[i]).first); // Search for nums[i] in the BST and delete it from the BST. } // get final tree maximum ans.push_back(*window.rbegin()); return ans; }}; ComplexityTime: $O(nlogn)$Space: $O(k)$ Method 3 - DequeMonotonic Queue: 單調遞減佇列 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MonotonicQueue {public: // pop掉所有比e小的元素，並push back void push(int e); // amortize time: O(1) // pop掉最大值(因最大在front所以pop_front) void pop(); // peek最大值 int max() const;private: deque dq;};void MonotonicQueue::push(int e) { while(!dq.empty() && e > dq.back()) dq.pop_back(); dq.push_back(e);}void MonotonicQueue::pop() { dq.pop_front();}int MonotonicQueue::max() const { return dq.front();}class Solution {public: vector maxSlidingWindow(vector& nums, int k) { vector ans; MonotonicQueue mq; for(int i = 0; i < nums.size(); i++) { mq.push(nums[i]); if(i - k + 1 >= 0) { // window start index, record answer ans.push_back(mq.max()); if(nums[i - k + 1] == mq.max()) mq.pop(); // next window doesn't include first element of current window } } return ans; }}; ComplexityTime: $O(n)$Space: $O(k)$ Conclusion Method Time Space Run time Brute force O(nk) O(1) 220 ms BST O(nlogn) O(k) 124 ms Deque O(n) O(k) 84 ms Reference HackerRank - Deque-STL GeeksforGeeks - Sliding Window Maximum (Maximum of all subarrays of size k) Youtube - Hua Hua document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/01/10/leetcode-sliding-window-maximum/"},{"title":"Python - NLTK函式庫基本功能介紹與自然語言處理","text":"12import nltk# nltk.download() conda安裝nltk後引入函式庫，第一次使用可由nltk.download()下載所需檔案 Tokenization1paragraph = \"\"\"An aircraft is a vehicle that is able to fly by gaining support from the air. It counters the force of gravity by using either static lift or by using the dynamic lift of an airfoil, or in a few cases the downward thrust from jet engines. Common examples of aircraft include airplanes, helicopters, airships (including blimps), gliders, paramotors and hot air balloons. The human activity that surrounds aircraft is called aviation. The science of aviation, including designing and building aircraft, is called aeronautics. Crewed aircraft are flown by an onboard pilot, but unmanned aerial vehicles may be remotely controlled or self-controlled by onboard computers. Aircraft may be classified by different criteria, such as lift type, aircraft propulsion, usage and others.\"\"\" Tokenization是指將整份文件分離出單字、句子、片語等等 1nltk.sent_tokenize(paragraph) ['An aircraft is a vehicle that is able to fly by gaining support from the air.', 'It counters the force of gravity by using either static lift or by using the dynamic lift of an airfoil, or in a few cases the downward thrust from jet engines.', 'Common examples of aircraft include airplanes, helicopters, airships (including blimps), gliders, paramotors and hot air balloons.', 'The human activity that surrounds aircraft is called aviation.', 'The science of aviation, including designing and building aircraft, is called aeronautics.', 'Crewed aircraft are flown by an onboard pilot, but unmanned aerial vehicles may be remotely controlled or self-controlled by onboard computers.', 'Aircraft may be classified by different criteria, such as lift type, aircraft propulsion, usage and others.']一般對文章做word tokenization，可以用python的split()做到 1234str = \"I am Lin\"words = str.split(\" \")# Out: ['I', 'am', 'Lin'] nltk則提供nltk.word_tokenize() 12words = nltk.word_tokenize(paragraph)words ['An', 'aircraft', 'is', 'a', 'vehicle', 'that', 'is', 'able', 'to', 'fly', 'by', 'gaining', 'support', 'from', 'the', 'air', '.', 'It', 'counters', 'the', 'force', 'of', 'gravity', 'by', 'using', 'either', 'static', 'lift', 'or', 'by', 'using', 'the', 'dynamic', 'lift', 'of', 'an', 'airfoil', ',', 'or', 'in', 'a', 'few', 'cases', 'the', 'downward', 'thrust', 'from', 'jet', 'engines', '.', 'Common', 'examples', 'of', 'aircraft', 'include', 'airplanes', ',', 'helicopters', ',', 'airships', '(', 'including', 'blimps', ')', ',', 'gliders', ',', 'paramotors', 'and', 'hot', 'air', 'balloons', '.', 'The', 'human', 'activity', 'that', 'surrounds', 'aircraft', 'is', 'called', 'aviation', '.', 'The', 'science', 'of', 'aviation', ',', 'including', 'designing', 'and', 'building', 'aircraft', ',', 'is', 'called', 'aeronautics', '.', 'Crewed', 'aircraft', 'are', 'flown', 'by', 'an', 'onboard', 'pilot', ',', 'but', 'unmanned', 'aerial', 'vehicles', 'may', 'be', 'remotely', 'controlled', 'or', 'self-controlled', 'by', 'onboard', 'computers', '.', 'Aircraft', 'may', 'be', 'classified', 'by', 'different', 'criteria', ',', 'such', 'as', 'lift', 'type', ',', 'aircraft', 'propulsion', ',', 'usage', 'and', 'others', '.']Stemming & LemmatizationStemming是指將不同時態或是不同變化的詞縮減成一個單字，例如intelligence, intelligent, intelligently的stemming都是intelligen，going, goes, gone都是go，lemmatization則是字根化，就是把字還原到字根的型態，保留字義，例如intelligence, intelligent, intelligently是intelligent 因此lemmatization過程花費時間往往較長，也因為提取單字原意對於分析上較有幫助，常用在如question answering等等應用上。而對於字義影響相對不大的應用，如spam detection，則會用stemming提高效能。 1from nltk.stem import PorterStemmer 12sentences = nltk.sent_tokenize(paragraph)sentences ['An aircraft is a vehicle that is able to fly by gaining support from the air.', 'It counters the force of gravity by using either static lift or by using the dynamic lift of an airfoil, or in a few cases the downward thrust from jet engines.', 'Common examples of aircraft include airplanes, helicopters, airships (including blimps), gliders, paramotors and hot air balloons.', 'The human activity that surrounds aircraft is called aviation.', 'The science of aviation, including designing and building aircraft, is called aeronautics.', 'Crewed aircraft are flown by an onboard pilot, but unmanned aerial vehicles may be remotely controlled or self-controlled by onboard computers.', 'Aircraft may be classified by different criteria, such as lift type, aircraft propulsion, usage and others.']1stemmer = PorterStemmer() 12345678sentences_stem = []for i in range(len(sentences)): words = nltk.word_tokenize(sentences[i]) words_stem = [stemmer.stem(word) for word in words] sentences_stem.append(' '.join(words_stem)) sentences_stem ['An aircraft is a vehicl that is abl to fli by gain support from the air .', 'It counter the forc of graviti by use either static lift or by use the dynam lift of an airfoil , or in a few case the downward thrust from jet engin .', 'common exampl of aircraft includ airplan , helicopt , airship ( includ blimp ) , glider , paramotor and hot air balloon .', 'the human activ that surround aircraft is call aviat .', 'the scienc of aviat , includ design and build aircraft , is call aeronaut .', 'crew aircraft are flown by an onboard pilot , but unman aerial vehicl may be remot control or self-control by onboard comput .', 'aircraft may be classifi by differ criteria , such as lift type , aircraft propuls , usag and other .']可以看到stemming會直接縮減單字，如vehicle改成了vehicl 接下來用Lemmatization api處理文章 1from nltk.stem import WordNetLemmatizer 1lemmatizer = WordNetLemmatizer() 12345678sentences_lem = []for i in range(len(sentences)): words = nltk.word_tokenize(sentences[i]) words_lem = [lemmatizer.lemmatize(word) for word in words] sentences_lem.append(' '.join(words_lem)) sentences_lem ['An aircraft is a vehicle that is able to fly by gaining support from the air .', 'It counter the force of gravity by using either static lift or by using the dynamic lift of an airfoil , or in a few case the downward thrust from jet engine .', 'Common example of aircraft include airplane , helicopter , airship ( including blimp ) , glider , paramotors and hot air balloon .', 'The human activity that surround aircraft is called aviation .', 'The science of aviation , including designing and building aircraft , is called aeronautics .', 'Crewed aircraft are flown by an onboard pilot , but unmanned aerial vehicle may be remotely controlled or self-controlled by onboard computer .', 'Aircraft may be classified by different criterion , such a lift type , aircraft propulsion , usage and others .']Stop word removal英文中有很多字對於句子的理解沒有影響，例如連接詞、be動詞等等，例如”I am going to station.”只要有”I go station”其實就包含足夠意義。第一次使用可由nltk.download('stopwords')下載詞庫 1nltk.download('stopwords') [nltk_data] Downloading package stopwords to /home/yc/nltk_data... [nltk_data] Package stopwords is already up-to-date! True1from nltk.corpus import stopwords 12345678sentences_wo_stop = []for i in range(len(sentences)): words = nltk.word_tokenize(sentences[i]) words_wo_stop = [word for word in words if word not in stopwords.words('english')] sentences_wo_stop.append(' '.join(words_wo_stop)) sentences_wo_stop ['An aircraft vehicle able fly gaining support air .', 'It counters force gravity using either static lift using dynamic lift airfoil , cases downward thrust jet engines .', 'Common examples aircraft include airplanes , helicopters , airships ( including blimps ) , gliders , paramotors hot air balloons .', 'The human activity surrounds aircraft called aviation .', 'The science aviation , including designing building aircraft , called aeronautics .', 'Crewed aircraft flown onboard pilot , unmanned aerial vehicles may remotely controlled self-controlled onboard computers .', 'Aircraft may classified different criteria , lift type , aircraft propulsion , usage others .']12 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/09/08/nltk-natural-language-processing-introduction/"},{"title":"Node.js Debugging 筆記","text":"Command Line node版本一定要是8以上!! 進入debug mode1$node inspect app.js 操作: 單步執行 :1debug> n #next 進入REPL: 12debug> repl #進入REPL後可以輸入變數名稱查看其值，或執行任何js指令 #用Ctrl+C回到debug mode 全部執行12debug> c #continue #Ctrl+C離開debug mode 常用技巧: 程式插入中斷點 可以配合nodemon使用 123456789101112//app.jsvar person = { name : 'yc'};person.age = 25;debugger; //中斷點person.name = 'Mike';console.log(person); 執行inspect 1$node inspect app.js 然後continue 1debug> c 如此一來會直接跳到，中斷點 Chrome DevTools1. 進入debug mode1$node --inspect-brk app.js #也可用nodemon 2. 開啟Chrome1URL: chrome://inspect document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/05/11/nodejs-debugging/"},{"title":"Minecraft server架設&設定檔紀錄","text":"ShiginimaSE_v3100 (破解版 請自己找)Adderss: yc-minecraft.tk (已關閉) Setting Up a Minecraft Server on Google Compute Engine 官方已提供很詳盡的說明，架完後可用freenom的免費域名(最長1年免費)，就不用記IP。 Info 版本:1.12.2 地圖類型: 大型生態系 pvp: on 作弊: off 人數:20 server.properties1234567891011121314151617181920212223242526272829303132333435363738#Minecraft server properties#Fri Jun 29 04:31:51 UTC 2018max-tick-time=60000generator-settings=force-gamemode=falseallow-nether=truegamemode=0enable-query=falseplayer-idle-timeout=0difficulty=2spawn-monsters=trueop-permission-level=4pvp=truesnooper-enabled=truelevel-type=LARGEBIOMEShardcore=falseenable-command-block=falsemax-players=20network-compression-threshold=256resource-pack-sha1=max-world-size=29999984server-port=25565server-ip=spawn-npcs=trueallow-flight=falselevel-name=worldview-distance=10resource-pack=spawn-animals=truewhite-list=falsegenerate-structures=trueonline-mode=falsemax-build-height=256level-seed=prevent-proxy-connections=falseuse-native-transport=trueenable-rcon=falsemotd=YC Minecraft Server Rule 箱子資源可自取 苦力怕坑要填平(不用填滿) 據點 編號 座標 註 1 127,77,-43 最初重生點附近 2 -4737,65,542 林地宅邸 3 -1477,67,285 沙漠遺跡 4 -1780,69,394 沙漠村莊 5 -1482,67,285 沙漠遺跡 6 - - document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2018/06/21/minecraft-config/"},{"title":"React開發環境設定","text":"Babel Setup Babel是一種ES6編譯器，因為有些瀏覽器未支援新語法，所以需要轉換舊版語法 123npm initnpm install -g babel-cli@6.24.1npm install babel-preset-react@6.24.1 babel-preset-env@1.5.2 Compile1babel src/app.js --out-file=public/scripts/app.js --presets=env,react 更改即時編譯，搭配live-server使用更方便 1babel src/app.js --out-file=public/scripts/app.js --presets=env,react --watch Basic123456├─public│ │─index.html│ └─scripts│ └─app.js└─src └─app.js 12345678910111213141516 Basic 123456789101112// src/app.jsconst render = () => { const jsx = ( My APP ); ReactDOM.render(jsx, document.getElementById('app'))};render(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/02/17/react-js-v16-setup/"},{"title":"設置BeagleBone嵌入式硬體開發環境","text":"本篇要在Host端設置開發環境，編譯執行檔，並傳送給Remote device執行並測試程式。 Host: 作業系統為Windows10，我們還需要IDE、Tool-chian以及Make toolRemote device: BeagleBone Black Download Eclipse IDE for C/C++ Developers eclipse-cpp-oxygen-3a-win32-x86_64.zip 根據JDK是安裝32或64bit，選擇對應eclipse版本，下載後解壓縮，點及主程式選擇workspace路徑，可以用git repo儲存 Cross compilation tool-chian gcc-linaro-6.3.1-2017.02-i686-mingw32_arm-linux-gnueabihf.tar.xz “Make” exe file for Windows GnuWin New Workspace解壓Eclipse IDE for C/C++ Developers後執行主程式 加入Cross compiler prefix與path (bin資料夾路徑) 完成新增Project 安裝make tool for windows 接著，到eclipse IDE 右鍵 build project 會看到產生binary檔 接下來要將這個binary用Remote System Explorer傳送到BBB硬體去執行檔案，BBB就是我們的remote system 接著都按Next、同意license後完成 安裝完成後會需要重開IDE Remote SSH Terminal 之後都按Next、Finish 之後就能看到BBB的file system 從host端(Windows)傳送硬體可執行檔方法很簡單，直接拖曳到BBB的檔案系統即可 如此就能在IDE整合SSH連線 cd Desktop/ 給予執行權限 chmod +x TestProject 執行 ./TestProject 完成開發環境設置，之後就能在Host開發、編譯，在傳到BBB上執行程式。 Import Existing Projects :::infoimport project後可能需要重新新增cross compiler的絕對路徑cc-linaro-6.3.1-2017.02-i686-mingw32_arm-linux-gnueabihf\\bin以及設置remote ssh terminal::: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/10/16/setup-eclipse-ide-cross-compiler-tool-chain-for-beaglebone-hardware/"},{"title":"Signal Statistics and CMSIS-DSP","text":"Mean and Standard Deviation Mead 平均數 物理意義: DC signal (Direct current) 直流分量 Deviation deviates from the mean: Average deviation: 物理意義: 訊號樣本點與平均之距離 Standard Deviation 標準差 物理意義: 顯示單一個測量值(電壓)與平均值間可能偏差的程度(功率) Variance 變異數 物理意義: 描述訊號的波動範圍，表示訊號中交流分量的強弱，即交流訊號的平均功率 Signal ro Noise ratio (SNR) Coefficient of Variation Implementation12345678910float32_t signal_mean(float32_t *signal_src, uint32_t signal_length) { float32_t mean = 0.0; uint32_t i; for(i = 0; i < signal_length; i++) { mean = mean + signal_src[i]; } mean /= (float32_t)signal_length; return mean;} 1234567891011float32_t signal_variance(float32_t *signal_src, uint32_t signal_length, float32_t signal_mean) { float32_t variance = 0.0; uint32_t i; for(i = 0; i < signal_length; i++) { variance = variance + pow((signal_src[i] - signal_mean), 2); } variance /= (signal_length - 1); return variance;} 12345float32_t signal_standard_deviation (float32_t signal_variance) { float32_t std = sqrtf(signal_variance); return std;} CMSIS-DSPCMSIS為DSP應用處理數值(多使用float32_t等浮點數)，並最佳化，例如用迴圈做320樣本點float32_t訊號做平均數計算常常無法算出，使用函式庫則能做高效率的運算。包含以下幾種類別的運算 Basic math Filter Thransform Interpolation Complex math Control (PID) Fast math Statistical Matrix Support function (min. max, …) Data type Signed integers int8_t, int16_t, int32_t, int64_t Unsigned integers uint8_t, uint16_t, uint32_t, uint64_t Floating point float32_t, float64_t Fraction q7_t (8-bit), q15_t (16-bit), q31_t (32-bit), q63_t (64-bit) ARM Math APIs arm_mean_f32 arm_var_f32 arm_std_f32 ADCADC consists of Sample/Hold and Quantizer to convert analog to digital. Sample/Hold: convert independent variable of signal from continuous to discrete Quantizer: convert dependent variable of signal from continuous to discrete Sampling theoremReconstructing original analog signal from sample points, the sample rate must satisfy , also called Nyquist theorem. RC Passive Filter Filter circuit is created by passive components such as capacitor, inductor and resistor. Design RC value 大川電子設計 online tool: http://sim.okawa-denshi.jp/en/Fkeisan.htm Capacitor Short circuit in high freq Open circuit in low freq Cut-off frequency 截止頻率 Low pass High pass Sallen-Key High-pass Filter (source: http://sim.okawa-denshi.jp/) Details: https://www.electronics-tutorials.ws/filter/sallen-key-filter.html More components (both passive and active components) means ploes and zeros, could achieve better performance. Analog filterThree common filter used for DSP application Bessel filter Better step response Chebyshev filter Better frequency response Butterworth filter document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/09/12/signal-statistics-CMSIS-DSP/"},{"title":"Nachos - 教學用作業系統","text":"Nachos作為教學用作業系統,需要實現簡潔並且儘量縮小與實際作業系統之間的差距,適合作為作業系統課程的教學實踐平臺。Nachos 是加州大學伯克萊分校在作業系統課程中已多次使用的作業系統課程設計平臺,在國內外很多大學中得到了應用,它在作業系統教學方面具有以下幾優點: 1. 採用通用虛擬機器Nachos 是建立在一個軟體類比的虛擬機器之上的,模擬了 MIPS R2/3000 的指令集、主記憶體、中斷系統、網路以及磁片系統等作業系統所必須的硬體系統。許多現代作業系統大多是先在用軟體類比的硬體上建立並測試,最後才在真正的硬體上運行。用軟體類比硬體的可靠性比真實硬體高得多,不會因為硬體故障而導致系統出錯,便於測試。虛擬機器可以在運行時報告詳盡的出錯資訊,更重要的是採用虛擬機器使 Nachos 的移植變得非常容易,在不同機器上移植 Nachos,只需對虛擬機器部分作移植即可。 採用 R2/3000 指令集的原因是該指令集為 RISC 指令集,其指令數目比較少。Nachos虛擬機器類比了其中的 63 條指令。由於 R2/3000 指令集是一個比較常用的指令集,許多現有的編譯器如 gc++能夠直接將 C 或 C++來源程式編譯成該指令集的目標代碼,於是就不必編寫編譯器,讀者就可以直接用 C/C++語言編寫應用程式,使得在 Nachos 上開發大型的應用程式也成為可能。 2. 使用並實現了作業系統中的一些新的概念隨著電腦技術和作業系統技術的不斷發展,產生了很多新的概念。Nachos 將這些新概念融入作業系統教學中,包括網路、執行緒和分散式應用。而且 Nachos 以執行緒作為一個基本概念講述,取代了行程在以前作業系統教學中的地位。Nachos 的虛擬機器使得網路的實現相當簡單。與 MINIX 不同,Nachos 只是一個在宿主機上運行的一個行程。在同一個宿主機上可以運行多個 Nachos 行程,各個行程可以相互通訊,作為一個全互連網路的一個節點;行程之間通過 Socket 進行通訊,類比了一個全互連網路。 3. 確定性測試比較方便;隨機因素使系統運行更加真實因為作業系統的不確定性,所以在一個實際的系統中進行多執行緒測試是比較困難的。由於 Nachos 是在宿主機上運行的行程,它提供了確定性測試的手段。所謂確定性測試,就是在同樣的輸入順序、輸入參數的情況下,Nachos 運行的結果是完全一樣的。在多執行緒測試中,可以將注意力集中在某一個實際問題上,而不受作業系統不確定性的干擾。另外,不確定性是作業系統所必須具有的特徵,Nachos 採用了隨機因數類比了真實作業系統的不確定性。 4. 簡單而易於擴展Nachos 是一個教學用作業系統平臺,它必須簡單而且有一定的擴展餘地。Nachos 不是向讀者展示一個成功的作業系統,而是讓讀者在一個框架下發揮自己的創造性進行擴展。例如一個完整的類似於 UNIX 的檔案系統是很複雜的,但是對於檔案系統來說,無非是需要實現檔的邏輯位址到物理位址的映射以及實現檔 inode、打開檔結構、執行緒打開檔表等重要的資料結構以及維護它們之間的關係。Nachos 中具有所有這些內容,但是在很多方面作了一定的限制,比如只有一級索引結構限制了系統中最大檔的大小。讀者可以應用學到的各種知識對檔案系統進行擴展,逐步消除這些限制。Nachos 在每一部分給出很多課程作業,作為讀者進行系統擴展的提示和檢查對系統擴展的結果。 5. 物件導向性Nachos 的主體是用 C++的一個子集來實現的。目前物件導向語言日漸流行,它能夠清楚地描述作業系統各個部分的介面。Nachos 沒有用到物件導向語言的所有特徵,如繼承性、多態性等,所以它的代碼就更容易閱讀和理解。 Nachos的實驗環境軟體架構 下載與安裝虛擬機 Oracle VM VirtualBox https://www.virtualbox.org/ Download 32-bit Ubuntu 14.04 http://releases.ubuntu.com/14.04/ 所需軟體Install g++ and csh 123sudo apt-get install g++sudo apt-get install cshsudo apt-get install make Download NachOS & Cross Compiler 12curl -O http://homepage.ntu.edu.tw/~r07943154/files/OS2019/nachos-4.0.tar.gzcurl -O http://homepage.ntu.edu.tw/~r07943154/files/OS2019/mips-decstation.linux-xgcc.gz 安裝untar nachos-4.0.tar.gz 1tar -xvf nachos-4.0.tar.gz move mips-decstation.linux-xgcc.gz to root and untar 123sudo mv mips-decstation.linux-xgcc.gz /cd /sudo tar -zxvf mips-decstation.linux-xgcc.gz Make NachOS-4.0 12cd ~/nachos-4.0/codemake 測試12cd ./userprog./nachos -e ../test/test1 1234567Total threads number is 1Thread ../test/test1 is executing.Print integer:9Print integer:8Print integer:7Print integer:6return value:0 Nachos的目錄結構以上作業系統可以發現在工作目錄下生成一個名為 nachos-4.0 的目錄。該目錄中含有: 檔名 類型 內容 copyright 文件 Nachos的版權 readme 文件 Nachos的readme資訊 nachos.ps 文件 Nachos 的介紹文檔(Postscript 格式) c++example 目錄 有關 C++介紹和實例 doc 目錄 Nachos 各個部分介紹和原有的作業要求 code 目錄 Nachos 各個部分的原始程式碼 最主要的部分是 Nachos 的原始程式碼部分。它的目錄結構是: 檔名 類型 內容 Makefile 文件 Nachos 的 Makefile 文件。當 Nachos 需要移植到其它系統時,可以修改 Makefile.dep 中的 HOST 參數 Makefile.common 文件 Makefile.dep 文件 machine 目錄 虛擬機器類比部分原始程式碼 threads 目錄 Nachos 執行緒管理部分原始程式碼 filesys 目錄 Nachos 檔案系統管理部分原始程式碼 userprog 目錄 Nachos 使用者程式部分原始程式碼 network 目錄 Nachos 網路管理部分原始程式碼 vm 目錄 Nachos 虛擬記憶體管理部分原始程式碼 test 目錄 一些測試用應用程式 bin 目錄 包含有使用者程式目的碼變換的程式 參考 General Nachos Documentation Wiki - Not Another Completely Heuristic Operating System A Road Map Through Nachos University of Pittsburgh - NachOS document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/08/27/what-is-nachos/"},{"title":"Setup 100MHz HCLK and ST-LINK debugger for logic analyzer of Keil IDE","text":"FIR fliter This project will go through the setup steps for DSP application on ARM CortexM4 processor AlgorithmThe FIR filter algorithm is based upon a sequence of multiply-accumulate (MAC) operations. Each filter coefficient $b[n]$ is multiplied by a state variable which equals a previous input sample $x[n]$. Finite Impulse Response filterpCoeffs points to a coefficient array of size numTaps. Coefficients are stored in time reversed order. $${b[numTaps-1], b[numTaps-2], b[N-2], …, b[1], b[0]}$$pState points to a state array of size numTaps + blockSize - 1. Samples in the state buffer are stored in the following order. $${x[n-numTaps+1], x[n-numTaps], x[n-numTaps-1], x[n-numTaps-2]….x[0], x[1], …, x[blockSize-1]}$$Note that the length of the state buffer exceeds the length of the coefficient array by blockSize-1. The increased state buffer length allows circular addressing, which is traditionally used in the FIR filters, to be avoided and yields a significant speed improvement. The state variables are updated after each block of data is processed; the coefficients are untouched. Finite Impulse Response filter 1. New Project and Logic Analyzer Select Libraries Add main.c to project Set frequency Setup debugger Check default frequency 12345678910111213141516171819#include \"stm32f4xx_hal.h\" // Keil::Device:STM32Cube HAL:Commonuint32_t freq; // In debug mode, add this variable to watch windowint main () { HAL_Init(); freq = HAL_RCC_GetHCLKFreq(); while(1) { }}void SysTick_Handler(void) { HAL_IncTick(); HAL_SYSTICK_IRQHandler();} Set trace core clock Test Logic analyzer12345678910111213141516171819202122232425#include \"stm32f4xx_hal.h\" // Keil::Device:STM32Cube HAL:Commonuint32_t freq;uint32_t counter = 50;int main () { //int i; HAL_Init(); freq = HAL_RCC_GetHCLKFreq(); while(1) { counter++; if(counter == 100) counter = 0; HAL_Delay(10); }}void SysTick_Handler(void) { HAL_IncTick(); HAL_SYSTICK_IRQHandler();} Set clock Use CubeMX, set HCLK to 100MHz Copy the SystemClock_Config code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include \"stm32f4xx_hal.h\" // Keil::Device:STM32Cube HAL:Commonvoid _Error_Handler(char *file, int line);void SystemClock_Config(void){ RCC_OscInitTypeDef RCC_OscInitStruct; RCC_ClkInitTypeDef RCC_ClkInitStruct; /**Configure the main internal regulator output voltage */ __HAL_RCC_PWR_CLK_ENABLE(); __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1); /**Initializes the CPU, AHB and APB busses clocks */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = 16; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 100; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 4; if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); } /**Initializes the CPU, AHB and APB busses clocks */ RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); } /**Configure the Systick interrupt time */ HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000); /**Configure the Systick */ HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK); /* SysTick_IRQn interrupt configuration */ HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);}/* USER CODE BEGIN 4 *//* USER CODE END 4 *//** * @brief This function is executed in case of error occurrence. * @param file: The file name as string. * @param line: The line in file as a number. * @retval None */void _Error_Handler(char *file, int line){ /* USER CODE BEGIN Error_Handler_Debug */ /* User can add his own implementation to report the HAL error return state */ while(1) { } /* USER CODE END Error_Handler_Debug */} Add clock.c and config function Check variable in watch window 2. Generate sin wave and plotPlot the wave below 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include \"arm_math.h\" // ARM::CMSIS:DSPfloat32_t inputSignal_f32_1kHz_15kHz[320] ={+0.0000000000f, +0.5924659585f, -0.0947343455f, +0.1913417162f, +1.0000000000f, +0.4174197128f, +0.3535533906f, +1.2552931065f, +0.8660254038f, +0.4619397663f, +1.3194792169f, +1.1827865776f, +0.5000000000f, +1.1827865776f, +1.3194792169f, +0.4619397663f, +0.8660254038f, +1.2552931065f, +0.3535533906f, +0.4174197128f, +1.0000000000f, +0.1913417162f, -0.0947343455f, +0.5924659585f, -0.0000000000f, -0.5924659585f, +0.0947343455f, -0.1913417162f, -1.0000000000f, -0.4174197128f, -0.3535533906f, -1.2552931065f, -0.8660254038f, -0.4619397663f, -1.3194792169f, -1.1827865776f, -0.5000000000f, -1.1827865776f, -1.3194792169f, -0.4619397663f, -0.8660254038f, -1.2552931065f, -0.3535533906f, -0.4174197128f, -1.0000000000f, -0.1913417162f, +0.0947343455f, -0.5924659585f, +0.0000000000f, +0.5924659585f, -0.0947343455f, +0.1913417162f, +1.0000000000f, +0.4174197128f, +0.3535533906f, +1.2552931065f, +0.8660254038f, +0.4619397663f, +1.3194792169f, +1.1827865776f, +0.5000000000f, +1.1827865776f, +1.3194792169f, +0.4619397663f, +0.8660254038f, +1.2552931065f, +0.3535533906f, +0.4174197128f, +1.0000000000f, +0.1913417162f, -0.0947343455f, +0.5924659585f, +0.0000000000f, -0.5924659585f, +0.0947343455f, -0.1913417162f, -1.0000000000f, -0.4174197128f, -0.3535533906f, -1.2552931065f, -0.8660254038f, -0.4619397663f, -1.3194792169f, -1.1827865776f, -0.5000000000f, -1.1827865776f, -1.3194792169f, -0.4619397663f, -0.8660254038f, -1.2552931065f, -0.3535533906f, -0.4174197128f, -1.0000000000f, -0.1913417162f, +0.0947343455f, -0.5924659585f, +0.0000000000f, +0.5924659585f, -0.0947343455f, +0.1913417162f, +1.0000000000f, +0.4174197128f, +0.3535533906f, +1.2552931065f, +0.8660254038f, +0.4619397663f, +1.3194792169f, +1.1827865776f, +0.5000000000f, +1.1827865776f, +1.3194792169f, +0.4619397663f, +0.8660254038f, +1.2552931065f, +0.3535533906f, +0.4174197128f, +1.0000000000f, +0.1913417162f, -0.0947343455f, +0.5924659585f, +0.0000000000f, -0.5924659585f, +0.0947343455f, -0.1913417162f, -1.0000000000f, -0.4174197128f, -0.3535533906f, -1.2552931065f, -0.8660254038f, -0.4619397663f, -1.3194792169f, -1.1827865776f, -0.5000000000f, -1.1827865776f, -1.3194792169f, -0.4619397663f, -0.8660254038f, -1.2552931065f, -0.3535533906f, -0.4174197128f, -1.0000000000f, -0.1913417162f, +0.0947343455f, -0.5924659585f, -0.0000000000f, +0.5924659585f, -0.0947343455f, +0.1913417162f, +1.0000000000f, +0.4174197128f, +0.3535533906f, +1.2552931065f, +0.8660254038f, +0.4619397663f, +1.3194792169f, +1.1827865776f, +0.5000000000f, +1.1827865776f, +1.3194792169f, +0.4619397663f, +0.8660254038f, +1.2552931065f, +0.3535533906f, +0.4174197128f, +1.0000000000f, +0.1913417162f, -0.0947343455f, +0.5924659585f, -0.0000000000f, -0.5924659585f, +0.0947343455f, -0.1913417162f, -1.0000000000f, -0.4174197128f, -0.3535533906f, -1.2552931065f, -0.8660254038f, -0.4619397663f, -1.3194792169f, -1.1827865776f, -0.5000000000f, -1.1827865776f, -1.3194792169f, -0.4619397663f, -0.8660254038f, -1.2552931065f, -0.3535533906f, -0.4174197128f, -1.0000000000f, -0.1913417162f, +0.0947343455f, -0.5924659585f, +0.0000000000f, +0.5924659585f, -0.0947343455f, +0.1913417162f, +1.0000000000f, +0.4174197128f, +0.3535533906f, +1.2552931065f, +0.8660254038f, +0.4619397663f, +1.3194792169f, +1.1827865776f, +0.5000000000f, +1.1827865776f, +1.3194792169f, +0.4619397663f, +0.8660254038f, +1.2552931065f, +0.3535533906f, +0.4174197128f, +1.0000000000f, +0.1913417162f, -0.0947343455f, +0.5924659585f, +0.0000000000f, -0.5924659585f, +0.0947343455f, -0.1913417162f, -1.0000000000f, -0.4174197128f, -0.3535533906f, -1.2552931065f, -0.8660254038f, -0.4619397663f, -1.3194792169f, -1.1827865776f, -0.5000000000f, -1.1827865776f, -1.3194792169f, -0.4619397663f, -0.8660254038f, -1.2552931065f, -0.3535533906f, -0.4174197128f, -1.0000000000f, -0.1913417162f, +0.0947343455f, -0.5924659585f, -0.0000000000f, +0.5924659585f, -0.0947343455f, +0.1913417162f, +1.0000000000f, +0.4174197128f, +0.3535533906f, +1.2552931065f, +0.8660254038f, +0.4619397663f, +1.3194792169f, +1.1827865776f, +0.5000000000f, +1.1827865776f, +1.3194792169f, +0.4619397663f, +0.8660254038f, +1.2552931065f, +0.3535533906f, +0.4174197128f, +1.0000000000f, +0.1913417162f, -0.0947343455f, +0.5924659585f, +0.0000000000f, -0.5924659585f, +0.0947343455f, -0.1913417162f, -1.0000000000f, -0.4174197128f, -0.3535533906f, -1.2552931065f, -0.8660254038f, -0.4619397663f, -1.3194792169f, -1.1827865776f, -0.5000000000f, -1.1827865776f, -1.3194792169f, -0.4619397663f, -0.8660254038f, -1.2552931065f, -0.3535533906f, -0.4174197128f, -1.0000000000f, -0.1913417162f, +0.0947343455f, -0.5924659585f, -0.0000000000f, +0.5924659585f, -0.0947343455f, +0.1913417162f, +1.0000000000f, +0.4174197128f, +0.3535533906f, +1.2552931065f, +0.8660254038f, +0.4619397663f, +1.3194792169f, +1.1827865776f, +0.5000000000f, +1.1827865776f, +1.3194792169f, +0.4619397663f, +0.8660254038f, +1.2552931065f, +0.3535533906f, +0.4174197128f, +1.0000000000f, +0.1913417162f, -0.0947343455f, +0.5924659585f, +0.0000000000f, -0.5924659585f, +0.0947343455f, -0.1913417162f, -1.0000000000f, -0.4174197128f, -0.3535533906f, -1.2552931065f, }; 12345678910111213141516171819202122232425262728293031323334353637383940#include \"stm32f4xx_hal.h\" // Keil::Device:STM32Cube HAL:Common#include \"arm_math.h\" // ARM::CMSIS:DSP#define SIG_LENGTH 320uint32_t freq;extern void SystemClock_Config(void);extern float32_t inputSignal_f32_1kHz_15kHz[SIG_LENGTH];void plot_Sin_wave(void);float32_t inputSample;int main (void) { HAL_Init(); SystemClock_Config(); freq = HAL_RCC_GetHCLKFreq(); plot_Sin_wave(); while(1) { }}void plot_Sin_wave(void) { int i, j; for(i = 0; i < SIG_LENGTH; i++) { inputSample = inputSignal_f32_1kHz_15kHz[i]; for(j = 0; j < 3000; j++) {}; // delay }}void SysTick_Handler(void) { HAL_IncTick(); HAL_SYSTICK_IRQHandler();} 3. Filter by given coefficientGiven coeff below 123456const float32_t firCoeffs32[NUM_TAPS] = { -0.0018225230f, -0.0015879294f, +0.0000000000f, +0.0036977508f, +0.0080754303f, +0.0085302217f, -0.0000000000f, -0.0173976984f, -0.0341458607f, -0.0333591565f, +0.0000000000f, +0.0676308395f, +0.1522061835f, +0.2229246956f, +0.2504960933f, +0.2229246956f, +0.1522061835f, +0.0676308395f, +0.0000000000f, -0.0333591565f, -0.0341458607f, -0.0173976984f, -0.0000000000f, +0.0085302217f, +0.0080754303f, +0.0036977508f, +0.0000000000f, -0.0015879294f, -0.0018225230f}; Source code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include \"stm32f4xx_hal.h\" // Keil::Device:STM32Cube HAL:Common#include \"arm_math.h\" // ARM::CMSIS:DSP#define SIG_LENGTH 320#define NUM_TAPS 29#define BLOCK_SIZE 32uint32_t freq;extern void SystemClock_Config(void);extern float32_t inputSignal_f32_1kHz_15kHz[SIG_LENGTH];void plot_Sin_wave(void);void plot_output_signal(void);void plot_both(void);// Variable for logic analyzerfloat32_t inputSample;float32_t outputSample;/// FIR Low-pass filter/// Given Coeffconst float32_t firCoeffs32[NUM_TAPS] = { -0.0018225230f, -0.0015879294f, +0.0000000000f, +0.0036977508f, +0.0080754303f, +0.0085302217f, -0.0000000000f, -0.0173976984f, -0.0341458607f, -0.0333591565f, +0.0000000000f, +0.0676308395f, +0.1522061835f, +0.2229246956f, +0.2504960933f, +0.2229246956f, +0.1522061835f, +0.0676308395f, +0.0000000000f, -0.0333591565f, -0.0341458607f, -0.0173976984f, -0.0000000000f, +0.0085302217f, +0.0080754303f, +0.0036977508f, +0.0000000000f, -0.0015879294f, -0.0018225230f};static float32_t firState_f32[BLOCK_SIZE + NUM_TAPS - 1];const uint32_t NUM_OF_BLOCKs = SIG_LENGTH / BLOCK_SIZE;float32_t outputSignal_f32[SIG_LENGTH];int main (void) { HAL_Init(); SystemClock_Config(); freq = HAL_RCC_GetHCLKFreq();/// FIR Low-pass filter// ARM DSP API// 1. Create fir object arm_fir_instance_f32 _1Khz_Khz_sig;// 2. Initialize arm_fir_init_f32( &_1Khz_Khz_sig, // points to an instance of the floating-point FIR filter structure NUM_TAPS, // number of filter coefficients in the filter (float32_t *)&firCoeffs32[0], // points to the filter coefficients buffer &firState_f32[0], // points to the state buffer BLOCK_SIZE // number of samples processed per call );// 3. Calculate for(int i = 0; i < NUM_OF_BLOCKs; i++) { arm_fir_f32( &_1Khz_Khz_sig, &inputSignal_f32_1kHz_15kHz[0] + (i * BLOCK_SIZE), // filter out block by block &outputSignal_f32[0] + (i * BLOCK_SIZE), // store output block by block BLOCK_SIZE ); }// plot_Sin_wave();// plot_output_signal(); plot_both(); while(1) {};}void plot_Sin_wave(void) { int i = 0, j; while(1) { inputSample = inputSignal_f32_1kHz_15kHz[i];for(j = 0; j < 3000; j++) {}; // delay i = (i == SIG_LENGTH - 1) ? 0 : i + 1;}}void plot_output_signal (void) { int i = 0, j; for(i = 0; i < SIG_LENGTH; i++) { outputSample = outputSignal_f32[i]; for(j = 0; j < 3000; j++) {} }}void plot_both(void) { int i, j; for(i = 0; i < SIG_LENGTH; i++) { inputSample = inputSignal_f32_1kHz_15kHz[i]; outputSample = outputSignal_f32[i]; for(j = 0; j < 8000; j++) {}//if(i == SIG_LENGTH - 1) i = 0; }}void SysTick_Handler(void) { HAL_IncTick(); HAL_SYSTICK_IRQHandler();} Signal Generation via Octive Generate 10 Hz sin wave for 3 sec Save as txt file 12345678f = 10; # 10HzAmp = 1;ts = 1/100;T = 3;t = 0:ts:T;y = Amp*sin(2*pi*f*t);csvwrite('_10hz_signal.txt', y); Reference http://www.keil.com/pack/doc/cmsis/DSP/html/group__FIR.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/09/11/stm32-dsp-fir-low-pass-filter/"},{"title":"BeagleBone eMMC 更新Debian至最新版本","text":"以下步驟將eMMC裡的舊版Debian更新成新版。 下載最新Debian 燒錄img檔至SD卡，我使用 balenaEtcher 這個軟體來寫入SD卡 用 3.3v FTDI接上板子上的 J1 Header，Putty打開FTDI的COM port (baud = 115200) 從SD卡開機 未上電的狀態下插入SD卡 按住板子上的S2按紐，插上電後再放開 登入Debian，預設帳號debian，密碼temppwd 目前只是從SD卡開機，eMMC還是舊版Debian 可看到登入時版本顯示為9.9，通常可用lsb_release -da指令確認，經測試8.7板可使用，9.9版本無法(?)，有待確認 從SD卡執行eMMC flasher script cd /opt/scripts/tools/eMMC/ sudo ./init-eMMC-flasher-v3.sh (作者Github) 便開始將新版Debian從SD卡燒錄到eMMC，實際上做以下的事 切割eMMC記憶體為兩部分，FAT與ext4，格式化與產生檔案系統 從SD卡內容複製到新的eMMC記憶體區塊 最後會自動關機 取出SD卡，重新上電 此時eMMC已經成功更新為Debian 9.9 透過USB分享網路BeagleBone Black不像Raspberry pi 3一樣有WiFi功能，所以一般使用要接Ethernet等方式上網，以下步驟在Windows環境分享目前電腦使用的網路給BeagleBone 打開putty，SSH連線至192.168.7.2 登入後，新增default gateway 輸入sudo route add default gw 192.168.7.1 usb0 加入DNS server sudo vim /etc/resolv.conf 如此便能成功上網。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/11/08/update-latest-Debian-img-on-beaglebone/"},{"title":"Leetcode - Two Sum IV - Input is a BST","text":"653. Two Sum IV - Input is a BSTGiven a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: 12345678910Input: 5 / \\ 3 6 / \\ \\2 4 7Target = 9Output: True Solution 注意因為一個和為k的pair可能同時在tree的左或右子樹，所以不能直接在tree結構搜尋，需要轉成陣列(原Two Sum Problem) 想用binary search來尋找pair，將BST轉成sorted序列，因此使用inorder traversal Code1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool findTarget(TreeNode* root, int k) { vector nums; function inorder = [&nums, &inorder](TreeNode* root) { if(!root) return; inorder(root->left); nums.push_back(root->val); inorder(root->right); }; inorder(root); // O(n) function binarySearch = [&](int l, int r, int t) { if(l t) return binarySearch(l, mid - 1, t); else return binarySearch(mid + 1, r, t); } return false; }; for(int i = 0; i < nums.size(); ++i) { // O(nlogn) if(binarySearch(i + 1, nums.size() - 1, k - nums[i])) return true; } return false; }}; Time complexity$O(nlogn)$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/01/15/leetcode-Two-Sum-IV-Input-is-a-BST/"}],"tags":[{"name":"Embedded","slug":"Embedded","link":"/tags/Embedded/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Decision Tree","slug":"Decision-Tree","link":"/tags/Decision-Tree/"},{"name":"Random Forest","slug":"Random-Forest","link":"/tags/Random-Forest/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Scikit-learn","slug":"Scikit-learn","link":"/tags/Scikit-learn/"},{"name":"K-Means","slug":"K-Means","link":"/tags/K-Means/"},{"name":"Linear Regression","slug":"Linear-Regression","link":"/tags/Linear-Regression/"},{"name":"KNN","slug":"KNN","link":"/tags/KNN/"},{"name":"SVM","slug":"SVM","link":"/tags/SVM/"},{"name":"Raspberry Pi","slug":"Raspberry-Pi","link":"/tags/Raspberry-Pi/"},{"name":"MJPEG-Streamer","slug":"MJPEG-Streamer","link":"/tags/MJPEG-Streamer/"},{"name":"Logistic Regrassion","slug":"Logistic-Regrassion","link":"/tags/Logistic-Regrassion/"},{"name":"Tensorflow","slug":"Tensorflow","link":"/tags/Tensorflow/"},{"name":"Deep Learning","slug":"Deep-Learning","link":"/tags/Deep-Learning/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"Jupyter","slug":"Jupyter","link":"/tags/Jupyter/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Anki","slug":"Anki","link":"/tags/Anki/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Embedded Linux","slug":"Embedded-Linux","link":"/tags/Embedded-Linux/"},{"name":"BeagleBone","slug":"BeagleBone","link":"/tags/BeagleBone/"},{"name":"Angstrom Linux","slug":"Angstrom-Linux","link":"/tags/Angstrom-Linux/"},{"name":"Semaphore","slug":"Semaphore","link":"/tags/Semaphore/"},{"name":"Multual exclusion","slug":"Multual-exclusion","link":"/tags/Multual-exclusion/"},{"name":"Facebook","slug":"Facebook","link":"/tags/Facebook/"},{"name":"Ngrok","slug":"Ngrok","link":"/tags/Ngrok/"},{"name":"base64","slug":"base64","link":"/tags/base64/"},{"name":"Firebase","slug":"Firebase","link":"/tags/Firebase/"},{"name":"jupyter","slug":"jupyter","link":"/tags/jupyter/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"imgur","slug":"imgur","link":"/tags/imgur/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"Time complexity","slug":"Time-complexity","link":"/tags/Time-complexity/"},{"name":"IoT","slug":"IoT","link":"/tags/IoT/"},{"name":"LoRa","slug":"LoRa","link":"/tags/LoRa/"},{"name":"NodeRED","slug":"NodeRED","link":"/tags/NodeRED/"},{"name":"MQTT","slug":"MQTT","link":"/tags/MQTT/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"matplotlib","slug":"matplotlib","link":"/tags/matplotlib/"},{"name":"DynamoDB","slug":"DynamoDB","link":"/tags/DynamoDB/"},{"name":"Verilog","slug":"Verilog","link":"/tags/Verilog/"},{"name":"FreeRTOS","slug":"FreeRTOS","link":"/tags/FreeRTOS/"},{"name":"STM32","slug":"STM32","link":"/tags/STM32/"},{"name":"ARM","slug":"ARM","link":"/tags/ARM/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"Hash Table","slug":"Hash-Table","link":"/tags/Hash-Table/"},{"name":"Linked-list","slug":"Linked-list","link":"/tags/Linked-list/"},{"name":"Backtracking","slug":"Backtracking","link":"/tags/Backtracking/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Matlab","slug":"Matlab","link":"/tags/Matlab/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"C3.js","slug":"C3-js","link":"/tags/C3-js/"},{"name":"IEEE754","slug":"IEEE754","link":"/tags/IEEE754/"},{"name":"BST","slug":"BST","link":"/tags/BST/"},{"name":"Multiset STL","slug":"Multiset-STL","link":"/tags/Multiset-STL/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Deque STL","slug":"Deque-STL","link":"/tags/Deque-STL/"},{"name":"Sliding Window","slug":"Sliding-Window","link":"/tags/Sliding-Window/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"NLTK","slug":"NLTK","link":"/tags/NLTK/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Minecraft","slug":"Minecraft","link":"/tags/Minecraft/"},{"name":"Google Compute Engine","slug":"Google-Compute-Engine","link":"/tags/Google-Compute-Engine/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"DSP","slug":"DSP","link":"/tags/DSP/"},{"name":"Debian","slug":"Debian","link":"/tags/Debian/"}],"categories":[{"name":"Embedded","slug":"Embedded","link":"/categories/Embedded/"},{"name":"FreeRTOS","slug":"Embedded/FreeRTOS","link":"/categories/Embedded/FreeRTOS/"},{"name":"Miscellaneous","slug":"Miscellaneous","link":"/categories/Miscellaneous/"},{"name":"IoT","slug":"IoT","link":"/categories/IoT/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Embedded Linux","slug":"Embedded/Embedded-Linux","link":"/categories/Embedded/Embedded-Linux/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","link":"/categories/Algorithm/LeetCode/"},{"name":"ARM","slug":"Embedded/ARM","link":"/categories/Embedded/ARM/"}]}